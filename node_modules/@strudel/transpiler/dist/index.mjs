import { evaluate as E } from "@strudel/core";
import { getLeafLocations as x } from "@strudel/mini";
import { parse as b } from "acorn";
import T from "escodegen";
import { walk as W } from "estree-walker";
let w = [];
function z(t) {
  w.push(t);
}
function d(t, i = {}) {
  const { wrapAsync: r = !1, addReturn: u = !0, emitMiniLocations: n = !0, emitWidgets: y = !0 } = i;
  let g = b(t, {
    ecmaVersion: 2022,
    allowAwaitOutsideFunction: !0,
    locations: !0
  }), p = [];
  const h = (e, o) => {
    const a = x(`"${e}"`, o.start, t);
    p = p.concat(a);
  };
  let c = [];
  W(g, {
    enter(e, o) {
      if (F(e)) {
        const a = e.quasi.quasis[0].value.raw, s = e.quasi.start + 1;
        if (n) {
          const f = O(a, s);
          p = p.concat(f);
        }
        return this.skip(), this.replace(R(a, s));
      }
      if ($(e, o)) {
        const { quasis: a } = e, { raw: s } = a[0].value;
        return this.skip(), n && h(s, e), this.replace(L(s, e));
      }
      if (S(e)) {
        const { value: a } = e;
        return this.skip(), n && h(a, e), this.replace(L(a, e));
      }
      if (k(e))
        return y && c.push({
          from: e.arguments[0].start,
          to: e.arguments[0].end,
          value: e.arguments[0].raw,
          // don't use value!
          min: e.arguments[1]?.value ?? 0,
          max: e.arguments[2]?.value ?? 1,
          step: e.arguments[3]?.value,
          type: "slider"
        }), this.replace(A(e));
      if (M(e)) {
        const a = e.callee.property.name, s = c.filter((v) => v.type === a).length, f = {
          to: e.end,
          index: s,
          type: a,
          id: i.id
        };
        return y && c.push(f), this.replace(I(e, f));
      }
      if (q(e, o))
        return this.replace(_(e));
      if (D(e))
        return this.replace(B(e));
    },
    leave(e, o, a, s) {
    }
  });
  const { body: l } = g;
  if (!l?.[l.length - 1]?.expression)
    throw new Error("unexpected ast format without body expression");
  if (u) {
    const { expression: e } = l[l.length - 1];
    l[l.length - 1] = {
      type: "ReturnStatement",
      argument: e
    };
  }
  let m = T.generate(g);
  return r && (m = `(async ()=>{${m}})()`), n ? { output: m, miniLocations: p, widgets: c } : { output: m };
}
function S(t, i, r) {
  return t.type !== "Literal" ? !1 : t.raw[0] === '"';
}
function $(t, i) {
  return t.type === "TemplateLiteral" && i.type !== "TaggedTemplateExpression";
}
function L(t, i) {
  const { start: r } = i;
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: "m"
    },
    arguments: [
      { type: "Literal", value: t },
      { type: "Literal", value: r }
    ],
    optional: !1
  };
}
function k(t) {
  return t.type === "CallExpression" && t.callee.name === "slider";
}
function M(t) {
  return t.type === "CallExpression" && w.includes(t.callee.property?.name);
}
function A(t) {
  const i = "slider_" + t.arguments[0].start;
  return t.arguments.unshift({
    type: "Literal",
    value: i,
    raw: i
  }), t.callee.name = "sliderWithID", t;
}
function C(t) {
  return `${t.id || ""}_widget_${t.type}_${t.index}`;
}
function I(t, i) {
  const r = C(i);
  return t.arguments.unshift({
    type: "Literal",
    value: r,
    raw: r
  }), t;
}
function q(t, i) {
  return t.type === "CallExpression" && t.callee.name === "samples" && i.type !== "AwaitExpression";
}
function _(t) {
  return {
    type: "AwaitExpression",
    argument: t
  };
}
function D(t) {
  return t.type === "LabeledStatement";
}
function B(t) {
  return {
    type: "ExpressionStatement",
    expression: {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: t.body.expression,
        property: {
          type: "Identifier",
          name: "p"
        }
      },
      arguments: [
        {
          type: "Literal",
          value: t.label.name,
          raw: `'${t.label.name}'`
        }
      ]
    }
  };
}
function F(t) {
  return t.type === "TaggedTemplateExpression" && t.tag.name === "tidal";
}
function O(t, i) {
  return t.split("").reduce((r, u, n) => (u !== '"' || (!r.length || r[r.length - 1].length > 1 ? r.push([n + 1]) : r[r.length - 1].push(n)), r), []).map(([r, u]) => {
    const n = t.slice(r, u);
    return x(`"${n}"`, i + r - 1);
  }).flat();
}
function R(t, i) {
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: "tidal"
    },
    arguments: [
      { type: "Literal", value: t },
      { type: "Literal", value: i }
    ],
    optional: !1
  };
}
const G = (t) => E(t, d);
export {
  G as evaluate,
  C as getWidgetID,
  z as registerWidgetType,
  d as transpiler
};
