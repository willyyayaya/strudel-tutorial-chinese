import * as I from "@strudel/core";
import { Pattern as m, clamp as q } from "@strudel/core";
import { setLogger as M, doughTrigger as $, superdough as A, getAudioContext as O, analysers as v, getAnalyzerData as z } from "superdough";
export * from "superdough";
import { getTheme as C, getDrawContext as T } from "@strudel/draw";
const { Pattern: D, logger: W, repl: B } = I;
M(W);
const P = (e) => (e.ensureObjectValue(), e.value), F = (e, t, r, s) => A(P(t), e - r, t.duration / s, s), j = (e, t, r, s, c) => A(P(e), c ? `=${c}` : t, r);
D.prototype.webaudio = function() {
  return this.onTrigger(F);
};
function K(e = {}) {
  return e = {
    getTime: () => O().currentTime,
    defaultOutput: j,
    ...e
  }, B(e);
}
D.prototype.dough = function() {
  return this.onTrigger($, 1);
};
function L(e, {
  align: t = !0,
  color: r = "white",
  thickness: s = 3,
  scale: c = 0.25,
  pos: a = 0.75,
  trigger: u = 0,
  ctx: o = T(),
  id: y = 1
} = {}) {
  o.lineWidth = s, o.strokeStyle = r;
  let p = o.canvas;
  if (!e) {
    o.beginPath();
    let l = a * p.height;
    o.moveTo(0, l), o.lineTo(p.width, l), o.stroke();
    return;
  }
  const n = z("time", y);
  o.beginPath();
  const g = e.frequencyBinCount;
  let h = t ? Array.from(n).findIndex((l, d, f) => d && f[d - 1] > -u && l <= -u) : 0;
  h = Math.max(h, 0);
  const w = p.width * 1 / g;
  let i = 0;
  for (let l = h; l < g; l++) {
    const d = n[l] + 1, f = (a - c * (d - 1)) * p.height;
    l === 0 ? o.moveTo(i, f) : o.lineTo(i, f), i += w;
  }
  o.stroke();
}
function V(e, { color: t = "white", scale: r = 0.25, pos: s = 0.75, lean: c = 0.5, min: a = -150, max: u = 0, ctx: o = T(), id: y = 1 } = {}) {
  if (!e) {
    o.beginPath();
    let i = s * n.height;
    o.moveTo(0, i), o.lineTo(n.width, i), o.stroke();
    return;
  }
  const p = z("frequency", y), n = o.canvas;
  o.fillStyle = t;
  const g = e.frequencyBinCount, h = n.width * 1 / g;
  let w = 0;
  for (let i = 0; i < g; i++) {
    const d = q((p[i] - a) / (u - a), 0, 1) * r, f = d * n.height, k = (s - d * c) * n.height;
    o.fillRect(w, k, Math.max(h, 1), f), w += h;
  }
}
function R(e = 0, t = "0,0,0", r = T()) {
  e ? (r.fillStyle = `rgba(${t},${1 - e})`, r.fillRect(0, 0, r.canvas.width, r.canvas.height)) : r.clearRect(0, 0, r.canvas.width, r.canvas.height);
}
m.prototype.fscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    () => {
      R(e.smear, "0,0,0", e.ctx), v[t] && V(v[t], e);
    },
    { id: t }
  );
};
m.prototype.tscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (r) => {
      e.color = r[0]?.value?.color || C().foreground, e.color, R(e.smear, "0,0,0", e.ctx), L(v[t], e);
    },
    { id: t }
  );
};
m.prototype.scope = m.prototype.tscope;
let S = {};
m.prototype.spectrum = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (r) => {
      e.color = r[0]?.value?.color || S[t] || C().foreground, S[t] = e.color, E(v[t], e);
    },
    { id: t }
  );
};
m.prototype.scope = m.prototype.tscope;
const b = /* @__PURE__ */ new Map();
function E(e, { thickness: t = 3, speed: r = 1, min: s = -80, max: c = 0, ctx: a = T(), id: u = 1, color: o } = {}) {
  if (a.lineWidth = t, a.strokeStyle = o, !e)
    return;
  const y = r, p = z("frequency", u), n = a.canvas;
  a.fillStyle = o;
  const g = e.frequencyBinCount;
  let h = b.get(u) || a.getImageData(0, 0, n.width, n.height);
  b.set(u, h), a.clearRect(0, 0, a.canvas.width, a.canvas.height), a.putImageData(h, -y, 0);
  let w = n.width - r;
  for (let i = 0; i < g; i++) {
    const l = q((p[i] - s) / (c - s), 0, 1);
    a.globalAlpha = l;
    const d = Math.log(i + 1) / Math.log(g) * n.height;
    a.fillRect(w, n.height - d, y, 2);
  }
  b.set(u, a.getImageData(0, 0, n.width, n.height));
}
export {
  V as drawFrequencyScope,
  L as drawTimeScope,
  j as webaudioOutput,
  F as webaudioOutputTrigger,
  K as webaudioRepl
};
