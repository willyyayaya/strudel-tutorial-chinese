import { map as Ce } from "nanostores";
if (typeof DelayNode < "u") {
  class t extends DelayNode {
    constructor(n, c, o, a) {
      super(n), c = Math.abs(c), this.delayTime.value = o;
      const s = n.createGain();
      s.gain.value = Math.min(Math.abs(a), 0.995), this.feedback = s.gain;
      const l = n.createGain();
      return l.gain.value = c, this.delayGain = l, this.connect(s), this.connect(l), s.connect(this), this.connect = (d) => l.connect(d), this;
    }
    start(n) {
      this.delayGain.gain.setValueAtTime(this.delayGain.gain.value, n + this.delayTime.value);
    }
  }
  AudioContext.prototype.createFeedbackDelay = function(e, n, c) {
    return new t(this, e, n, c);
  };
}
var Yt = {};
Yt.generateReverb = function(t, e) {
  for (var n = t.audioContext || new AudioContext(), c = n.sampleRate, o = t.numChannels || 2, a = t.decayTime * 1.5, s = Math.round(t.decayTime * c), l = Math.round(a * c), d = Math.round((t.fadeInTime || 0) * c), r = Math.pow(1 / 1e3, 1 / s), i = n.createBuffer(o, l, c), b = 0; b < o; b++) {
    for (var u = i.getChannelData(b), m = 0; m < l; m++)
      u[m] = ke() * Math.pow(r, m);
    for (var m = 0; m < d; m++)
      u[m] *= m / d;
  }
  Ie(i, t.lpFreqStart || 0, t.lpFreqEnd || 0, t.decayTime, e);
};
Yt.generateGraph = function(t, e, n, c, o) {
  var a = document.createElement("canvas");
  a.width = e, a.height = n;
  var s = a.getContext("2d");
  s.fillStyle = "#000", s.fillRect(0, 0, a.width, a.height), s.fillStyle = "#fff";
  for (var l = e / t.length, d = n / (o - c), r = 0; r < t.length; r++)
    s.fillRect(r * l, n - (t[r] - c) * d, 1, 1);
  return a;
};
var Ie = function(t, e, n, c, o) {
  if (e == 0) {
    o(t);
    return;
  }
  var a = Pe(t), s = new OfflineAudioContext(t.numberOfChannels, a[0].length, t.sampleRate), l = s.createBufferSource();
  l.buffer = t;
  var d = s.createBiquadFilter();
  e = Math.min(e, t.sampleRate / 2), n = Math.min(n, t.sampleRate / 2), d.type = "lowpass", d.Q.value = 1e-4, d.frequency.setValueAtTime(e, 0), d.frequency.linearRampToValueAtTime(n, c), l.connect(d), d.connect(s.destination), l.start(), s.oncomplete = function(r) {
    o(r.renderedBuffer);
  }, s.startRendering(), window.filterNode = d;
}, Pe = function(t) {
  for (var e = [], n = 0; n < t.numberOfChannels; n++)
    e[n] = t.getChannelData(n);
  return e;
}, ke = function() {
  return Math.random() * 2 - 1;
};
typeof AudioContext < "u" && (AudioContext.prototype.adjustLength = function(t, e) {
  const n = e.sampleRate * t, c = this.createBuffer(e.numberOfChannels, e.length, e.sampleRate);
  for (let o = 0; o < e.numberOfChannels; o++) {
    let a = e.getChannelData(o), s = c.getChannelData(o);
    for (let l = 0; l < n; l++)
      s[l] = a[l] || 0;
  }
  return c;
}, AudioContext.prototype.createReverb = function(t, e, n, c, o) {
  const a = this.createConvolver();
  return a.generate = (s = 2, l = 0.1, d = 15e3, r = 1e3, i) => {
    a.duration = s, a.fade = l, a.lp = d, a.dim = r, a.ir = i, i ? a.buffer = this.adjustLength(s, i) : Yt.generateReverb(
      {
        audioContext: this,
        numChannels: 2,
        decayTime: s,
        fadeInTime: l,
        lpFreqStart: d,
        lpFreqEnd: r
      },
      (b) => {
        a.buffer = b;
      }
    );
  }, a.generate(t, e, n, c, o), a;
});
var oe = {
  a: { freqs: [660, 1120, 2750, 3e3, 3350], gains: [1, 0.5012, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  e: { freqs: [440, 1800, 2700, 3e3, 3300], gains: [1, 0.1995, 0.1259, 0.1, 0.1], qs: [70, 80, 100, 120, 120] },
  i: { freqs: [270, 1850, 2900, 3350, 3590], gains: [1, 0.0631, 0.0631, 0.0158, 0.0158], qs: [40, 90, 100, 120, 120] },
  o: { freqs: [430, 820, 2700, 3e3, 3300], gains: [1, 0.3162, 0.0501, 0.0794, 0.01995], qs: [40, 80, 100, 120, 120] },
  u: { freqs: [370, 630, 2750, 3e3, 3400], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ae: { freqs: [650, 1515, 2400, 3e3, 3350], gains: [1, 0.5, 0.1008, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  aa: { freqs: [560, 900, 2570, 3e3, 3300], gains: [1, 0.5, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  oe: { freqs: [500, 1430, 2300, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ue: { freqs: [250, 1750, 2150, 3200, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  y: { freqs: [400, 1460, 2400, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  uh: { freqs: [600, 1250, 2100, 3100, 3500], gains: [1, 0.3, 0.0608, 0.0316, 0.01995], qs: [40, 70, 100, 120, 130] },
  un: { freqs: [500, 1240, 2280, 3e3, 3500], gains: [1, 0.1, 0.1708, 0.0216, 0.02995], qs: [40, 60, 100, 120, 120] },
  en: { freqs: [600, 1480, 2450, 3200, 3300], gains: [1, 0.15, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  an: { freqs: [700, 1050, 2500, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  on: { freqs: [500, 1080, 2350, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  get æ() {
    return this.ae;
  },
  get ø() {
    return this.oe;
  },
  get ɑ() {
    return this.aa;
  },
  get å() {
    return this.aa;
  },
  get ö() {
    return this.oe;
  },
  get ü() {
    return this.ue;
  },
  get ı() {
    return this.y;
  }
};
if (typeof GainNode < "u") {
  class t extends GainNode {
    constructor(n, c) {
      if (super(n), !oe[c])
        throw new Error("vowel: unknown vowel " + c);
      const { gains: o, qs: a, freqs: s } = oe[c], l = n.createGain();
      for (let d = 0; d < 5; d++) {
        const r = n.createGain();
        r.gain.value = o[d];
        const i = n.createBiquadFilter();
        i.type = "bandpass", i.Q.value = a[d], i.frequency.value = s[d], this.connect(i), i.connect(r), r.connect(l);
      }
      return l.gain.value = 8, this.connect = (d) => l.connect(d), this;
    }
  }
  AudioContext.prototype.createVowelFilter = function(e) {
    return new t(this, e);
  };
}
let ie = (t) => console.log(t);
const F = (...t) => ie(...t), Tn = (t) => {
  ie = t;
}, Be = (t) => {
  if (typeof t != "string")
    return [];
  const [e, n = "", c] = t.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)?.slice(1) || [];
  return e ? [e, n, c ? Number(c) : void 0] : [];
}, ve = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, Qe = { "#": 1, b: -1, s: 1, f: -1 }, yt = (t, e = 3) => {
  const [n, c, o = e] = Be(t);
  if (!n)
    throw new Error('not a note: "' + t + '"');
  const a = ve[n.toLowerCase()], s = c?.split("").reduce((l, d) => l + Qe[d], 0) || 0;
  return (Number(o) + 1) * 12 + a + s;
}, ue = (t) => Math.pow(2, (t - 69) / 12) * 440, st = (t, e, n) => Math.min(Math.max(t, e), n), je = (t) => 12 * Math.log(t / 440) / Math.LN2 + 69, Ue = (t, e) => {
  if (typeof t != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: c } = t;
  return typeof n == "number" ? je(n) : typeof c == "string" ? yt(c) : typeof c == "number" ? c : e;
};
function Q(t, e = 0, n) {
  return isNaN(Number(t)) ? (!n && F(`"${t}" is not a number, falling back to ${e}`, "warning"), e) : t;
}
const me = (t, e) => (t % e + e) % e, se = (t, e) => me(Math.round(Q(t, 0)), e), Oe = "data:text/javascript;base64,KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHZ0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLm5iSW5wdXRzPXQubnVtYmVyT2ZJbnB1dHMsdGhpcy5uYk91dHB1dHM9dC5udW1iZXJPZk91dHB1dHMsdGhpcy5ibG9ja1NpemU9dC5wcm9jZXNzb3JPcHRpb25zLmJsb2NrU2l6ZSx0aGlzLmhvcFNpemU9MTI4LHRoaXMubmJPdmVybGFwcz10aGlzLmJsb2NrU2l6ZS90aGlzLmhvcFNpemUsdGhpcy5pbnB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpLHRoaXMuaW5wdXRCdWZmZXJzSGVhZD1uZXcgQXJyYXkodGhpcy5uYklucHV0cyksdGhpcy5pbnB1dEJ1ZmZlcnNUb1NlbmQ9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpO2ZvcihsZXQgZT0wO2U8dGhpcy5uYklucHV0cztlKyspdGhpcy5hbGxvY2F0ZUlucHV0Q2hhbm5lbHMoZSwxKTt0aGlzLm91dHB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJPdXRwdXRzKSx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlPW5ldyBBcnJheSh0aGlzLm5iT3V0cHV0cyk7Zm9yKGxldCBlPTA7ZTx0aGlzLm5iT3V0cHV0cztlKyspdGhpcy5hbGxvY2F0ZU91dHB1dENoYW5uZWxzKGUsMSl9cmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKXtmb3IobGV0IHM9MDtzPHRoaXMubmJJbnB1dHM7cysrKXtsZXQgcj10W3NdLmxlbmd0aDtyIT10aGlzLmlucHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVJbnB1dENoYW5uZWxzKHMscil9Zm9yKGxldCBzPTA7czx0aGlzLm5iT3V0cHV0cztzKyspe2xldCByPWVbc10ubGVuZ3RoO3IhPXRoaXMub3V0cHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVPdXRwdXRDaGFubmVscyhzLHIpfX1hbGxvY2F0ZUlucHV0Q2hhbm5lbHModCxlKXt0aGlzLmlucHV0QnVmZmVyc1t0XT1uZXcgQXJyYXkoZSk7Zm9yKGxldCBzPTA7czxlO3MrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKzEyOCksdGhpcy5pbnB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLmlucHV0QnVmZmVyc0hlYWRbdF09bmV3IEFycmF5KGUpLHRoaXMuaW5wdXRCdWZmZXJzVG9TZW5kW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMuaW5wdXRCdWZmZXJzSGVhZFt0XVtzXT10aGlzLmlucHV0QnVmZmVyc1t0XVtzXS5zdWJhcnJheSgwLHRoaXMuYmxvY2tTaXplKSx0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKX1hbGxvY2F0ZU91dHB1dENoYW5uZWxzKHQsZSl7dGhpcy5vdXRwdXRCdWZmZXJzW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1RvUmV0cmlldmVbdF1bc109bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJsb2NrU2l6ZSksdGhpcy5vdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZVt0XVtzXS5maWxsKDApfXJlYWRJbnB1dHModCl7aWYodFswXS5sZW5ndGgmJnRbMF1bMF0ubGVuZ3RoPT0wKXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5maWxsKDAsdGhpcy5ibG9ja1NpemUpO3JldHVybn1mb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dFtlXVtzXTt0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5zZXQocix0aGlzLmJsb2NrU2l6ZSl9fXdyaXRlT3V0cHV0cyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dGhpcy5vdXRwdXRCdWZmZXJzW2VdW3NdLnN1YmFycmF5KDAsMTI4KTt0W2VdW3NdLnNldChyKX19c2hpZnRJbnB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KX1zaGlmdE91dHB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJPdXRwdXRzO3QrKylmb3IobGV0IGU9MDtlPHRoaXMub3V0cHV0QnVmZmVyc1t0XS5sZW5ndGg7ZSsrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bZV0uc3ViYXJyYXkodGhpcy5ibG9ja1NpemUtMTI4KS5maWxsKDApfXByZXBhcmVJbnB1dEJ1ZmZlcnNUb1NlbmQoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtlXS5zZXQodGhpcy5pbnB1dEJ1ZmZlcnNIZWFkW3RdW2VdKX1oYW5kbGVPdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5uYk91dHB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5vdXRwdXRCdWZmZXJzW3RdLmxlbmd0aDtlKyspZm9yKGxldCBzPTA7czx0aGlzLmJsb2NrU2l6ZTtzKyspdGhpcy5vdXRwdXRCdWZmZXJzW3RdW2VdW3NdKz10aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdW2VdW3NdL3RoaXMubmJPdmVybGFwc31wcm9jZXNzKHQsZSxzKXtjb25zdCBuPXRbMF1bMF0hPT12b2lkIDA7cmV0dXJuIHRoaXMuc3RhcnRlZCYmIW4/ITE6KHRoaXMuc3RhcnRlZD1uLHRoaXMucmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKSx0aGlzLnJlYWRJbnB1dHModCksdGhpcy5zaGlmdElucHV0QnVmZmVycygpLHRoaXMucHJlcGFyZUlucHV0QnVmZmVyc1RvU2VuZCgpLHRoaXMucHJvY2Vzc09MQSh0aGlzLmlucHV0QnVmZmVyc1RvU2VuZCx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlLHMpLHRoaXMuaGFuZGxlT3V0cHV0QnVmZmVyc1RvUmV0cmlldmUoKSx0aGlzLndyaXRlT3V0cHV0cyhlKSx0aGlzLnNoaWZ0T3V0cHV0QnVmZmVycygpLCEwKX1wcm9jZXNzT0xBKHQsZSxzKXtjb25zb2xlLmFzc2VydCghMSwiTm90IG92ZXJyaWRlbiIpfX1jbGFzcyBndHtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLnNpemU9dHwwLHRoaXMuc2l6ZTw9MXx8dGhpcy5zaXplJnRoaXMuc2l6ZS0xKXRocm93IG5ldyBFcnJvcigiRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMSIpO3RoaXMuX2NzaXplPXQ8PDE7Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNpemUqMikscz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3QgYT1NYXRoLlBJKnMvdGhpcy5zaXplO2Vbc109TWF0aC5jb3MoYSksZVtzKzFdPS1NYXRoLnNpbihhKX10aGlzLnRhYmxlPWU7Zm9yKHZhciByPTAsbj0xO3RoaXMuc2l6ZT5uO248PD0xKXIrKzt0aGlzLl93aWR0aD1yJTI9PT0wP3ItMTpyLHRoaXMuX2JpdHJldj1uZXcgQXJyYXkoMTw8dGhpcy5fd2lkdGgpO2Zvcih2YXIgaT0wO2k8dGhpcy5fYml0cmV2Lmxlbmd0aDtpKyspe3RoaXMuX2JpdHJldltpXT0wO2Zvcih2YXIgaD0wO2g8dGhpcy5fd2lkdGg7aCs9Mil7dmFyIGM9dGhpcy5fd2lkdGgtaC0yO3RoaXMuX2JpdHJldltpXXw9KGk+Pj5oJjMpPDxjfX10aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5faW52PTB9ZnJvbUNvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHxuZXcgQXJyYXkodC5sZW5ndGg+Pj4xKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKXNbcj4+PjFdPXRbcl07cmV0dXJuIHN9Y3JlYXRlQ29tcGxleEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fY3NpemUpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09MDtyZXR1cm4gdH10b0NvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHx0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpLHI9MDtyPHMubGVuZ3RoO3IrPTIpc1tyXT10W3I+Pj4xXSxzW3IrMV09MDtyZXR1cm4gc31jb21wbGV0ZVNwZWN0cnVtKHQpe2Zvcih2YXIgZT10aGlzLl9jc2l6ZSxzPWU+Pj4xLHI9MjtyPHM7cis9Mil0W2Utcl09dFtyXSx0W2UtcisxXT0tdFtyKzFdfXRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9cmVhbFRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3JlYWxUcmFuc2Zvcm00KCksdGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsfWludmVyc2VUcmFuc2Zvcm0odCxlKXtpZih0PT09ZSl0aHJvdyBuZXcgRXJyb3IoIklucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCIpO3RoaXMuX291dD10LHRoaXMuX2RhdGE9ZSx0aGlzLl9pbnY9MSx0aGlzLl90cmFuc2Zvcm00KCk7Zm9yKHZhciBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXS89dGhpcy5zaXplO3RoaXMuX291dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1fdHJhbnNmb3JtNCgpe3ZhciB0PXRoaXMuX291dCxlPXRoaXMuX2NzaXplLHM9dGhpcy5fd2lkdGgscj0xPDxzLG49ZS9yPDwxLGksaCxjPXRoaXMuX2JpdHJldjtpZihuPT09NClmb3IoaT0wLGg9MDtpPGU7aSs9bixoKyspe2NvbnN0IG09Y1toXTt0aGlzLl9zaW5nbGVUcmFuc2Zvcm0yKGksbSxyKX1lbHNlIGZvcihpPTAsaD0wO2k8ZTtpKz1uLGgrKyl7Y29uc3QgbT1jW2hdO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTQoaSxtLHIpfXZhciBhPXRoaXMuX2ludj8tMToxLHU9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7bj1lL3I8PDE7dmFyIGY9bj4+PjI7Zm9yKGk9MDtpPGU7aSs9bilmb3IodmFyIHA9aStmLGw9aSxkPTA7bDxwO2wrPTIsZCs9cil7Y29uc3QgbT1sLGc9bStmLHY9ZytmLEk9ditmLF89dFttXSx3PXRbbSsxXSxiPXRbZ10sQj10W2crMV0sVD10W3ZdLFA9dFt2KzFdLHk9dFtJXSxBPXRbSSsxXSx4PV8sRj13LFY9dVtkXSxNPWEqdVtkKzFdLE89YipWLUIqTSxOPWIqTStCKlYsWT11WzIqZF0sTD1hKnVbMipkKzFdLEg9VCpZLVAqTCxVPVQqTCtQKlksSz11WzMqZF0sWj1hKnVbMypkKzFdLCQ9eSpLLUEqWixHPXkqWitBKkssaj14K0gsQz1GK1Usaz14LUgsSj1GLVUsUT1PKyQsej1OK0csRT1hKihPLSQpLFg9YSooTi1HKSxldD1qK1EsaXQ9Qyt6LG90PWotUSxhdD1DLXosaHQ9aytYLHV0PUotRSxjdD1rLVgsbHQ9SitFO3RbbV09ZXQsdFttKzFdPWl0LHRbZ109aHQsdFtnKzFdPXV0LHRbdl09b3QsdFt2KzFdPWF0LHRbSV09Y3QsdFtJKzFdPWx0fX19X3NpbmdsZVRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG49dGhpcy5fZGF0YSxpPW5bZV0saD1uW2UrMV0sYz1uW2Urc10sYT1uW2UrcysxXSx1PWkrYyxmPWgrYSxwPWktYyxsPWgtYTtyW3RdPXUsclt0KzFdPWYsclt0KzJdPXAsclt0KzNdPWx9X3NpbmdsZVRyYW5zZm9ybTQodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG49dGhpcy5fZGF0YSxpPXRoaXMuX2ludj8tMToxLGg9cyoyLGM9cyozLGE9bltlXSx1PW5bZSsxXSxmPW5bZStzXSxwPW5bZStzKzFdLGw9bltlK2hdLGQ9bltlK2grMV0sbT1uW2UrY10sZz1uW2UrYysxXSx2PWErbCxJPXUrZCxfPWEtbCx3PXUtZCxiPWYrbSxCPXArZyxUPWkqKGYtbSksUD1pKihwLWcpLHk9ditiLEE9SStCLHg9XytQLEY9dy1ULFY9di1iLE09SS1CLE89Xy1QLE49dytUO3JbdF09eSxyW3QrMV09QSxyW3QrMl09eCxyW3QrM109RixyW3QrNF09VixyW3QrNV09TSxyW3QrNl09TyxyW3QrN109Tn1fcmVhbFRyYW5zZm9ybTQoKXt2YXIgdD10aGlzLl9vdXQsZT10aGlzLl9jc2l6ZSxzPXRoaXMuX3dpZHRoLHI9MTw8cyxuPWUvcjw8MSxpLGgsYz10aGlzLl9iaXRyZXY7aWYobj09PTQpZm9yKGk9MCxoPTA7aTxlO2krPW4saCsrKXtjb25zdCBmdD1jW2hdO3RoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKGksZnQ+Pj4xLHI+Pj4xKX1lbHNlIGZvcihpPTAsaD0wO2k8ZTtpKz1uLGgrKyl7Y29uc3QgZnQ9Y1toXTt0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtNChpLGZ0Pj4+MSxyPj4+MSl9dmFyIGE9dGhpcy5faW52Py0xOjEsdT10aGlzLnRhYmxlO2ZvcihyPj49MjtyPj0yO3I+Pj0yKXtuPWUvcjw8MTt2YXIgZj1uPj4+MSxwPWY+Pj4xLGw9cD4+PjE7Zm9yKGk9MDtpPGU7aSs9bilmb3IodmFyIGQ9MCxtPTA7ZDw9bDtkKz0yLG0rPXIpe3ZhciBnPWkrZCx2PWcrcCxJPXYrcCxfPUkrcCx3PXRbZ10sYj10W2crMV0sQj10W3ZdLFQ9dFt2KzFdLFA9dFtJXSx5PXRbSSsxXSxBPXRbX10seD10W18rMV0sRj13LFY9YixNPXVbbV0sTz1hKnVbbSsxXSxOPUIqTS1UKk8sWT1CKk8rVCpNLEw9dVsyKm1dLEg9YSp1WzIqbSsxXSxVPVAqTC15KkgsSz1QKkgreSpMLFo9dVszKm1dLCQ9YSp1WzMqbSsxXSxHPUEqWi14KiQsaj1BKiQreCpaLEM9RitVLGs9VitLLEo9Ri1VLFE9Vi1LLHo9TitHLEU9WStqLFg9YSooTi1HKSxldD1hKihZLWopLGl0PUMreixvdD1rK0UsYXQ9SitldCxodD1RLVg7aWYodFtnXT1pdCx0W2crMV09b3QsdFt2XT1hdCx0W3YrMV09aHQsZD09PTApe3ZhciB1dD1DLXosY3Q9ay1FO3RbSV09dXQsdFtJKzFdPWN0O2NvbnRpbnVlfWlmKGQhPT1sKXt2YXIgbHQ9Six6dD0tUSxFdD1DLFJ0PS1rLER0PS1hKmV0LHF0PS1hKlgsV3Q9LWEqRSxZdD0tYSp6LEx0PWx0K0R0LEh0PXp0K3F0LFV0PUV0K1l0LEt0PVJ0LVd0LGR0PWkrcC1kLG10PWkrZi1kO3RbZHRdPUx0LHRbZHQrMV09SHQsdFttdF09VXQsdFttdCsxXT1LdH19fX1fc2luZ2xlUmVhbFRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG49dGhpcy5fZGF0YSxpPW5bZV0saD1uW2Urc10sYz1pK2gsYT1pLWg7clt0XT1jLHJbdCsxXT0wLHJbdCsyXT1hLHJbdCszXT0wfV9zaW5nbGVSZWFsVHJhbnNmb3JtNCh0LGUscyl7Y29uc3Qgcj10aGlzLl9vdXQsbj10aGlzLl9kYXRhLGk9dGhpcy5faW52Py0xOjEsaD1zKjIsYz1zKjMsYT1uW2VdLHU9bltlK3NdLGY9bltlK2hdLHA9bltlK2NdLGw9YStmLGQ9YS1mLG09dStwLGc9aSoodS1wKSx2PWwrbSxJPWQsXz0tZyx3PWwtbSxiPWQsQj1nO3JbdF09dixyW3QrMV09MCxyW3QrMl09SSxyW3QrM109XyxyW3QrNF09dyxyW3QrNV09MCxyW3QrNl09YixyW3QrN109Qn19Y29uc3QgUj0obyx0LGUpPT5NYXRoLm1pbihNYXRoLm1heChvLHQpLGUpLEl0PShvLHQpPT4obyV0K3QpJXQsRD0xMjg7ZnVuY3Rpb24gYnQobyx0KXtyZXR1cm4gbzx0PyhvLz10LG8rby1vKm8tMSk6bz4xLXQ/KG89KG8tMSkvdCxvKm8rbytvKzEpOjB9Y29uc3Qgc3Q9e3RyaShvLHQ9LjUpe2NvbnN0IGU9MS10O3JldHVybiBvPj10PzEvZS1vL2U6by90fSxzaW5lKG8pe3JldHVybiBNYXRoLnNpbihNYXRoLlBJKjIqbykqLjUrLjV9LHJhbXAobyl7cmV0dXJuIG99LHNhdyhvKXtyZXR1cm4gMS1vfSxzcXVhcmUobyx0PS41KXtyZXR1cm4gbz49dD8wOjF9LGN1c3RvbShvLHQ9WzAsMV0pe2NvbnN0IGU9dC5sZW5ndGgtMSxzPU1hdGguZmxvb3IobyplKSxyPTEvZSxuPVIodFtzXSwwLDEpLGg9Uih0W3MrMV0sMCwxKSxjPW4sYT0wLHU9cjtyZXR1cm4oaC1jKS8odS1hKSooby1yKnMpK259LHNhd2JsZXAobyx0KXtyZXR1cm4gMipvLTEtYnQobyx0KX19O2Z1bmN0aW9uIHEobyx0KXtyZXR1cm4gdC5sZW5ndGg+MT90W29dOnRbMF19Y29uc3QgQnQ9T2JqZWN0LmtleXMoc3QpO2NsYXNzIF90IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6InRpbWUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MH0se25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToic2tldyIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToiZGVwdGgiLGRlZmF1bHRWYWx1ZToxfSx7bmFtZToicGhhc2VvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToic2hhcGUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZGNvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGhhc2V9aW5jcmVtZW50UGhhc2UodCl7dGhpcy5waGFzZSs9dCx0aGlzLnBoYXNlPjEmJih0aGlzLnBoYXNlPXRoaXMucGhhc2UtMSl9cHJvY2Vzcyh0LGUscyl7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO2NvbnN0IHI9ZVswXSxuPXMuZnJlcXVlbmN5WzBdLGk9cy50aW1lWzBdLGg9cy5kZXB0aFswXSxjPXMuc2tld1swXSxhPXMucGhhc2VvZmZzZXRbMF0sdT1zLmRjb2Zmc2V0WzBdLGY9QnRbcy5zaGFwZVswXV0scD1yWzBdLmxlbmd0aD8/MDt0aGlzLnBoYXNlPT1udWxsJiYodGhpcy5waGFzZT1JdChpKm4rYSwxKSk7Y29uc3QgbD1uL3NhbXBsZVJhdGU7Zm9yKGxldCBkPTA7ZDxwO2QrKyl7Zm9yKGxldCBtPTA7bTxyLmxlbmd0aDttKyspe2NvbnN0IGc9KHN0W2ZdKHRoaXMucGhhc2UsYykrdSkqaDtyW21dW2RdPWd9dGhpcy5pbmNyZW1lbnRQaGFzZShsKX1yZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoImxmby1wcm9jZXNzb3IiLF90KTtjbGFzcyB3dCBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJjb2Fyc2UiLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbj1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2xldCBoPXMuY29hcnNlWzBdPz8wO2g9TWF0aC5tYXgoMSxoKTtmb3IobGV0IGM9MDtjPEQ7YysrKWZvcihsZXQgYT0wO2E8ci5sZW5ndGg7YSsrKW5bYV1bY109YyVoPT09MD9yW2FdW2NdOm5bYV1bYy0xXTtyZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoImNvYXJzZS1wcm9jZXNzb3IiLHd0KTtjbGFzcyBTdCBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJjcnVzaCIsZGVmYXVsdFZhbHVlOjB9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxuPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7bGV0IGg9cy5jcnVzaFswXT8/ODtoPU1hdGgubWF4KDEsaCk7Zm9yKGxldCBjPTA7YzxEO2MrKylmb3IobGV0IGE9MDthPHIubGVuZ3RoO2ErKyl7Y29uc3QgdT1NYXRoLnBvdygyLGgtMSk7blthXVtjXT1NYXRoLnJvdW5kKHJbYV1bY10qdSkvdX1yZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoImNydXNoLXByb2Nlc3NvciIsU3QpO2NsYXNzIFR0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6InNoYXBlIixkZWZhdWx0VmFsdWU6MH0se25hbWU6InBvc3RnYWluIixkZWZhdWx0VmFsdWU6MX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITF9cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG49ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtsZXQgaD1zLnNoYXBlWzBdO2g9aDwxP2g6MS00ZS0xMCxoPTIqaC8oMS1oKTtjb25zdCBjPU1hdGgubWF4KC4wMDEsTWF0aC5taW4oMSxzLnBvc3RnYWluWzBdKSk7Zm9yKGxldCBhPTA7YTxEO2ErKylmb3IobGV0IHU9MDt1PHIubGVuZ3RoO3UrKyluW3VdW2FdPSgxK2gpKnJbdV1bYV0vKDEraCpNYXRoLmFicyhyW3VdW2FdKSkqYztyZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoInNoYXBlLXByb2Nlc3NvciIsVHQpO2Z1bmN0aW9uIFMobyl7Y29uc3QgdD1vKm87cmV0dXJuIG8qKDI3K3QpLygyNys5KnQpfWNvbnN0IHB0PTMuMTQxNTkyNjUzNTk7Y2xhc3MgUHQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NTAwfSx7bmFtZToicSIsZGVmYXVsdFZhbHVlOjF9LHtuYW1lOiJkcml2ZSIsZGVmYXVsdFZhbHVlOi42OX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITEsdGhpcy5wMD1bMCwwXSx0aGlzLnAxPVswLDBdLHRoaXMucDI9WzAsMF0sdGhpcy5wMz1bMCwwXSx0aGlzLnAzMj1bMCwwXSx0aGlzLnAzMz1bMCwwXSx0aGlzLnAzND1bMCwwXX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbj1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2NvbnN0IGg9cy5xWzBdLGM9UihNYXRoLmV4cChzLmRyaXZlWzBdKSwuMSwyZTMpO2xldCBhPXMuZnJlcXVlbmN5WzBdO2E9YSoyKnB0L3NhbXBsZVJhdGUsYT1hPjE/MTphO2NvbnN0IHU9TWF0aC5taW4oOCxoKi4xMyk7bGV0IGY9MS9jKk1hdGgubWluKDEuNzUsMSt1KTtmb3IobGV0IHA9MDtwPEQ7cCsrKWZvcihsZXQgbD0wO2w8ci5sZW5ndGg7bCsrKXtjb25zdCBkPXRoaXMucDNbbF0qLjM2MDg5MSt0aGlzLnAzMltsXSouNDE3MjkrdGhpcy5wMzNbbF0qLjE3Nzg5Nit0aGlzLnAzNFtsXSouMDQzOTcyNTt0aGlzLnAzNFtsXT10aGlzLnAzM1tsXSx0aGlzLnAzM1tsXT10aGlzLnAzMltsXSx0aGlzLnAzMltsXT10aGlzLnAzW2xdLHRoaXMucDBbbF0rPShTKHJbbF1bcF0qYy11KmQpLVModGhpcy5wMFtsXSkpKmEsdGhpcy5wMVtsXSs9KFModGhpcy5wMFtsXSktUyh0aGlzLnAxW2xdKSkqYSx0aGlzLnAyW2xdKz0oUyh0aGlzLnAxW2xdKS1TKHRoaXMucDJbbF0pKSphLHRoaXMucDNbbF0rPShTKHRoaXMucDJbbF0pLVModGhpcy5wM1tsXSkpKmEsbltsXVtwXT1kKmZ9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJsYWRkZXItcHJvY2Vzc29yIixQdCk7Y2xhc3MgeXQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiZGlzdG9ydCIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJwb3N0Z2FpbiIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxuPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7Y29uc3QgaD1NYXRoLmV4cG0xKHMuZGlzdG9ydFswXSksYz1NYXRoLm1heCguMDAxLE1hdGgubWluKDEscy5wb3N0Z2FpblswXSkpO2ZvcihsZXQgYT0wO2E8RDthKyspZm9yKGxldCB1PTA7dTxyLmxlbmd0aDt1Kyspblt1XVthXT0oMStoKSpyW3VdW2FdLygxK2gqTWF0aC5hYnMoclt1XVthXSkpKmM7cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJkaXN0b3J0LXByb2Nlc3NvciIseXQpO2Z1bmN0aW9uIEF0KG8sdCxlKXtyZXR1cm4gZSoodC1vKStvfWZ1bmN0aW9uIHh0KG8sdCxlKXtyZXR1cm4gbzwyPzA6QXQoLXQqLjUsdCouNSxlLyhvLTEpKX1mdW5jdGlvbiBydChvLHQpe3JldHVybiBvKk1hdGgucG93KDIsdC8xMil9Y2xhc3MgRnQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGhhc2U9W119c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiYmVnaW4iLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJlbmQiLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJmcmVxdWVuY3kiLGRlZmF1bHRWYWx1ZTo0NDAsbWluOk51bWJlci5FUFNJTE9OfSx7bmFtZToicGFuc3ByZWFkIixkZWZhdWx0VmFsdWU6LjQsbWluOjAsbWF4OjF9LHtuYW1lOiJmcmVxc3ByZWFkIixkZWZhdWx0VmFsdWU6LjIsbWluOjB9LHtuYW1lOiJkZXR1bmUiLGRlZmF1bHRWYWx1ZTowLG1pbjowfSx7bmFtZToidm9pY2VzIixkZWZhdWx0VmFsdWU6NSxtaW46MX1dfXByb2Nlc3ModCxlLHMpe2lmKGN1cnJlbnRUaW1lPD1zLmJlZ2luWzBdKXJldHVybiEwO2lmKGN1cnJlbnRUaW1lPj1zLmVuZFswXSlyZXR1cm4hMTtsZXQgcj1zLmZyZXF1ZW5jeVswXTtyPXIqTWF0aC5wb3coMixzLmRldHVuZVswXS8xMjAwKTtjb25zdCBuPWVbMF0saT1zLnZvaWNlc1swXSxoPXMuZnJlcXNwcmVhZFswXSxjPXMucGFuc3ByZWFkWzBdKi41Ky41LGE9TWF0aC5zcXJ0KDEtYyksdT1NYXRoLnNxcnQoYyk7Zm9yKGxldCBmPTA7ZjxpO2YrKyl7Y29uc3QgcD0oZiYxKT09MSxsPXJ0KHIseHQoaSxoLGYpKTtsZXQgZD1hLG09dTtwJiYoZD11LG09YSk7Y29uc3QgZz1sL3NhbXBsZVJhdGU7Zm9yKGxldCB2PTA7djxuWzBdLmxlbmd0aDt2Kyspe3RoaXMucGhhc2VbZl09dGhpcy5waGFzZVtmXT8/TWF0aC5yYW5kb20oKTtjb25zdCBJPXN0LnNhd2JsZXAodGhpcy5waGFzZVtmXSxnKTtuWzBdW3ZdPW5bMF1bdl0rSSpkLG5bMV1bdl09blsxXVt2XStJKm0sdGhpcy5waGFzZVtmXSs9Zyx0aGlzLnBoYXNlW2ZdPjEmJih0aGlzLnBoYXNlW2ZdPXRoaXMucGhhc2VbZl0tMSl9fXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3Nvcigic3VwZXJzYXctb3NjaWxsYXRvciIsRnQpO2NvbnN0IFZ0PTIwNDg7ZnVuY3Rpb24gTXQobyl7bGV0IHQ9bmV3IEZsb2F0MzJBcnJheShvKTtmb3IodmFyIGU9MDtlPG87ZSsrKXRbZV09LjUqKDEtTWF0aC5jb3MoMipNYXRoLlBJKmUvbykpO3JldHVybiB0fWNsYXNzIE90IGV4dGVuZHMgdnR7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToicGl0Y2hGYWN0b3IiLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IodCl7dC5wcm9jZXNzb3JPcHRpb25zPXtibG9ja1NpemU6VnR9LHN1cGVyKHQpLHRoaXMuZmZ0U2l6ZT10aGlzLmJsb2NrU2l6ZSx0aGlzLnRpbWVDdXJzb3I9MCx0aGlzLmhhbm5XaW5kb3c9TXQodGhpcy5ibG9ja1NpemUpLHRoaXMuZmZ0PW5ldyBndCh0aGlzLmZmdFNpemUpLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXI9dGhpcy5mZnQuY3JlYXRlQ29tcGxleEFycmF5KCksdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQ9dGhpcy5mZnQuY3JlYXRlQ29tcGxleEFycmF5KCksdGhpcy50aW1lQ29tcGxleEJ1ZmZlcj10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLm1hZ25pdHVkZXM9bmV3IEZsb2F0MzJBcnJheSh0aGlzLmZmdFNpemUvMisxKSx0aGlzLnBlYWtJbmRleGVzPW5ldyBJbnQzMkFycmF5KHRoaXMubWFnbml0dWRlcy5sZW5ndGgpLHRoaXMubmJQZWFrcz0wfXByb2Nlc3NPTEEodCxlLHMpe2xldCByPXMucGl0Y2hGYWN0b3Jbcy5waXRjaEZhY3Rvci5sZW5ndGgtMV07cjwwJiYocj1yKi4yNSkscj1NYXRoLm1heCgwLHIrMSk7Zm9yKHZhciBuPTA7bjx0aGlzLm5iSW5wdXRzO24rKylmb3IodmFyIGk9MDtpPHRbbl0ubGVuZ3RoO2krKyl7dmFyIGg9dFtuXVtpXSxjPWVbbl1baV07dGhpcy5hcHBseUhhbm5XaW5kb3coaCksdGhpcy5mZnQucmVhbFRyYW5zZm9ybSh0aGlzLmZyZXFDb21wbGV4QnVmZmVyLGgpLHRoaXMuY29tcHV0ZU1hZ25pdHVkZXMoKSx0aGlzLmZpbmRQZWFrcygpLHRoaXMuc2hpZnRQZWFrcyhyKSx0aGlzLmZmdC5jb21wbGV0ZVNwZWN0cnVtKHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkKSx0aGlzLmZmdC5pbnZlcnNlVHJhbnNmb3JtKHRoaXMudGltZUNvbXBsZXhCdWZmZXIsdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQpLHRoaXMuZmZ0LmZyb21Db21wbGV4QXJyYXkodGhpcy50aW1lQ29tcGxleEJ1ZmZlcixjKSx0aGlzLmFwcGx5SGFubldpbmRvdyhjKX10aGlzLnRpbWVDdXJzb3IrPXRoaXMuaG9wU2l6ZX1hcHBseUhhbm5XaW5kb3codCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmJsb2NrU2l6ZTtlKyspdFtlXT10W2VdKnRoaXMuaGFubldpbmRvd1tlXSoxLjYyfWNvbXB1dGVNYWduaXR1ZGVzKCl7Zm9yKHZhciB0PTAsZT0wO3Q8dGhpcy5tYWduaXR1ZGVzLmxlbmd0aDspe2xldCBzPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZV0scj10aGlzLmZyZXFDb21wbGV4QnVmZmVyW2UrMV07dGhpcy5tYWduaXR1ZGVzW3RdPXMqKjIrcioqMix0Kz0xLGUrPTJ9fWZpbmRQZWFrcygpe3RoaXMubmJQZWFrcz0wO3ZhciB0PTI7bGV0IGU9dGhpcy5tYWduaXR1ZGVzLmxlbmd0aC0yO2Zvcig7dDxlOyl7bGV0IHM9dGhpcy5tYWduaXR1ZGVzW3RdO2lmKHRoaXMubWFnbml0dWRlc1t0LTFdPj1zfHx0aGlzLm1hZ25pdHVkZXNbdC0yXT49cyl7dCsrO2NvbnRpbnVlfWlmKHRoaXMubWFnbml0dWRlc1t0KzFdPj1zfHx0aGlzLm1hZ25pdHVkZXNbdCsyXT49cyl7dCsrO2NvbnRpbnVlfXRoaXMucGVha0luZGV4ZXNbdGhpcy5uYlBlYWtzXT10LHRoaXMubmJQZWFrcysrLHQrPTJ9fXNoaWZ0UGVha3ModCl7dGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQuZmlsbCgwKTtmb3IodmFyIGU9MDtlPHRoaXMubmJQZWFrcztlKyspe2xldCBpPXRoaXMucGVha0luZGV4ZXNbZV0saD1NYXRoLnJvdW5kKGkqdCk7aWYoaD50aGlzLm1hZ25pdHVkZXMubGVuZ3RoKWJyZWFrO3ZhciBzPTAscj10aGlzLmZmdFNpemU7aWYoZT4wKXtsZXQgdT10aGlzLnBlYWtJbmRleGVzW2UtMV07cz1pLU1hdGguZmxvb3IoKGktdSkvMil9aWYoZTx0aGlzLm5iUGVha3MtMSl7bGV0IHU9dGhpcy5wZWFrSW5kZXhlc1tlKzFdO3I9aStNYXRoLmNlaWwoKHUtaSkvMil9bGV0IGM9cy1pLGE9ci1pO2Zvcih2YXIgbj1jO248YTtuKyspe2xldCB1PWkrbixmPWgrbjtpZihmPj10aGlzLm1hZ25pdHVkZXMubGVuZ3RoKWJyZWFrO2xldCBwPTIqTWF0aC5QSSooZi11KS90aGlzLmZmdFNpemUsbD1NYXRoLmNvcyhwKnRoaXMudGltZUN1cnNvciksZD1NYXRoLnNpbihwKnRoaXMudGltZUN1cnNvciksbT11KjIsZz1tKzEsdj10aGlzLmZyZXFDb21wbGV4QnVmZmVyW21dLEk9dGhpcy5mcmVxQ29tcGxleEJ1ZmZlcltnXSxfPXYqbC1JKmQsdz12KmQrSSpsLGI9ZioyLEI9YisxO3RoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkW2JdKz1fLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkW0JdKz13fX19fXJlZ2lzdGVyUHJvY2Vzc29yKCJwaGFzZS12b2NvZGVyLXByb2Nlc3NvciIsT3QpO2NsYXNzIE50IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBpPXB0LHRoaXMucGhpPS10aGlzLnBpLHRoaXMuWTA9MCx0aGlzLlkxPTAsdGhpcy5QVz10aGlzLnBpLHRoaXMuQj0yLjMsdGhpcy5kcGhpZj0wLHRoaXMuZW52Zj0wfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6ImRldHVuZSIsZGVmYXVsdFZhbHVlOjAsbWluOk51bWJlci5ORUdBVElWRV9JTkZJTklUWSxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSx7bmFtZToicHVsc2V3aWR0aCIsZGVmYXVsdFZhbHVlOjEsbWluOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWX1dfXByb2Nlc3ModCxlLHMpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXJldHVybiExO2lmKGN1cnJlbnRUaW1lPD1zLmJlZ2luWzBdKXJldHVybiEwO2lmKGN1cnJlbnRUaW1lPj1zLmVuZFswXSlyZXR1cm4hMTtjb25zdCByPWVbMF07bGV0IG49MSxpO2ZvcihsZXQgaD0wO2g8KHJbMF0ubGVuZ3RoPz8wKTtoKyspe2NvbnN0IGM9KDEtUihxKGgscy5wdWxzZXdpZHRoKSwtLjk5LC45OSkpKnRoaXMucGksYT1xKGgscy5kZXR1bmUpLHU9cnQocShoLHMuZnJlcXVlbmN5KSxhLzEwMCk7aT11Kih0aGlzLnBpLyhzYW1wbGVSYXRlKi41KSksdGhpcy5kcGhpZis9LjEqKGktdGhpcy5kcGhpZiksbio9Ljk5OTgsdGhpcy5lbnZmKz0uMSoobi10aGlzLmVudmYpLHRoaXMuQj0yLjMqKDEtMWUtNCp1KSx0aGlzLkI8MCYmKHRoaXMuQj0wKSx0aGlzLnBoaSs9dGhpcy5kcGhpZix0aGlzLnBoaT49dGhpcy5waSYmKHRoaXMucGhpLT0yKnRoaXMucGkpO2xldCBmPU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkwKTt0aGlzLlkwPS41KihmK3RoaXMuWTApO2xldCBwPU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkxK2MpO3RoaXMuWTE9LjUqKHArdGhpcy5ZMSk7Zm9yKGxldCBsPTA7bDxyLmxlbmd0aDtsKyspcltsXVtoXT0uMTUqKGYtcCkqdGhpcy5lbnZmfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigicHVsc2Utb3NjaWxsYXRvciIsTnQpO2NvbnN0IG50PXtiaXRDOmZ1bmN0aW9uKG8sdCxlKXtyZXR1cm4gbyZ0P2U6MH0sYnI6ZnVuY3Rpb24obyx0PTgpe2lmKHQ+MzIpdGhyb3cgbmV3IEVycm9yKCJicigpIFNpemUgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAzMiIpO3tsZXQgZT0wO2ZvcihsZXQgcz0wO3M8dC0wO3MrKyllKz1udC5iaXRDKG8sMioqcywyKioodC0ocysxKSkpO3JldHVybiBlfX0sc2luZjpmdW5jdGlvbihvKXtyZXR1cm4gTWF0aC5zaW4oby8oMTI4L01hdGguUEkpKX0sY29zZjpmdW5jdGlvbihvKXtyZXR1cm4gTWF0aC5jb3Moby8oMTI4L01hdGguUEkpKX0sdGFuZjpmdW5jdGlvbihvKXtyZXR1cm4gTWF0aC50YW4oby8oMTI4L01hdGguUEkpKX0scmVnRzpmdW5jdGlvbihvLHQpe3JldHVybiB0LnRlc3Qoby50b1N0cmluZygyKSl9fTtsZXQgVyx0dDtmdW5jdGlvbiBDdChvKXtpZigoV3x8dHQpPT1udWxsKXtXPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hdGgpLHR0PVcubWFwKHM9Pk1hdGhbc10pO2NvbnN0IHQ9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobnQpLGU9dC5tYXAocz0+bnRbc10pO1cucHVzaCgiaW50Iiwid2luZG93IiwuLi50KSx0dC5wdXNoKE1hdGguZmxvb3IsZ2xvYmFsVGhpcywuLi5lKX1yZXR1cm4gbmV3IEZ1bmN0aW9uKC4uLlcsInQiLGByZXR1cm4gMCwKJHtvfHwwfTtgKS5iaW5kKGdsb2JhbFRoaXMsLi4udHQpfWNsYXNzIGt0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBvcnQub25tZXNzYWdlPXQ9PntsZXR7Y29kZVRleHQ6ZX09dC5kYXRhO2NvbnN0e2J5dGVCZWF0U3RhcnRUaW1lOnN9PXQuZGF0YTtzIT1udWxsJiYodGhpcy50PTAsdGhpcy5pbml0aWFsT2Zmc2V0PU1hdGguZmxvb3IocykpLGU9ZS50cmltKCkucmVwbGFjZSgvXmV2YWxcKHVuZXNjYXBlXChlc2NhcGUoPzpgfFwoJ3xcKCJ8XChgKSguKj8pKD86YHwnXCl8IlwpfGBcKSkucmVwbGFjZVwoXC91XChcLlwuXClcL2csWyInYF1cJDElWyInYF1cKVwpXCkkLywocixuKT0+dW5lc2NhcGUoZXNjYXBlKG4pLnJlcGxhY2UoL3UoLi4pL2csIiQxJSIpKSksdGhpcy5mdW5jPUN0KGUpfSx0aGlzLmluaXRpYWxPZmZzZXQ9bnVsbCx0aGlzLnQ9bnVsbCx0aGlzLmZ1bmM9bnVsbH1zdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJiZWdpbiIsZGVmYXVsdFZhbHVlOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtaW46MH0se25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOjQ0MCxtaW46TnVtYmVyLkVQU0lMT059LHtuYW1lOiJkZXR1bmUiLGRlZmF1bHRWYWx1ZTowLG1pbjpOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWX0se25hbWU6ImVuZCIsZGVmYXVsdFZhbHVlOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtaW46MH1dfXByb2Nlc3ModCxlLHMpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXJldHVybiExO2lmKGN1cnJlbnRUaW1lPD1zLmJlZ2luWzBdKXJldHVybiEwO2lmKGN1cnJlbnRUaW1lPj1zLmVuZFswXSlyZXR1cm4hMTt0aGlzLnQ9PW51bGwmJih0aGlzLnQ9cy5iZWdpblswXSpzYW1wbGVSYXRlKTtjb25zdCByPWVbMF07Zm9yKGxldCBuPTA7bjxyWzBdLmxlbmd0aDtuKyspe2NvbnN0IGk9cShuLHMuZGV0dW5lKSxoPXJ0KHEobixzLmZyZXF1ZW5jeSksaS8xMDApO2xldCBjPXRoaXMudC8oc2FtcGxlUmF0ZS8yNTYpKmgrdGhpcy5pbml0aWFsT2Zmc2V0O2NvbnN0IGY9KCh0aGlzLmZ1bmMoYykmMjU1KS8xMjcuNS0xKSouMjtmb3IobGV0IHA9MDtwPHIubGVuZ3RoO3ArKylyW3BdW25dPVIoZiwtLjQsLjQpO3RoaXMudD10aGlzLnQrMX1yZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoImJ5dGUtYmVhdC1wcm9jZXNzb3IiLGt0KX0pKCk7Cg==";
function k(t) {
  const e = G().createGain();
  return e.gain.value = t, e;
}
const ae = (t, e, n, c) => c - n === 0 ? 0 : (e - t) / (c - n);
function I(t, e, n, c) {
  const o = new AudioWorkletNode(t, e, c);
  return Object.entries(n).forEach(([a, s]) => {
    o.parameters.get(a).value = s;
  }), o;
}
const B = (t, e, n, c, o, a, s, l, d, r = "exponential") => {
  e = Q(e), n = Q(n), c = Q(c), o = Q(o);
  const i = r === "exponential" ? "exponentialRampToValueAtTime" : "linearRampToValueAtTime";
  r === "exponential" && (a = a === 0 ? 1e-3 : a, s = s === 0 ? 1e-3 : s);
  const b = s - a, u = s, m = a + c * b, X = d - l, Z = (p) => {
    let y;
    if (e > p) {
      let h = ae(a, u, 0, e);
      y = p * h + (a > u ? a : 0);
    } else
      y = (p - e) * ae(u, m, 0, n) + u;
    return r === "exponential" && (y = y || 1e-3), y;
  };
  t.setValueAtTime(a, l), e > X ? t[i](Z(X), d) : e + n > X ? (t[i](Z(e), l + e), t[i](Z(X), d)) : (t[i](Z(e), l + e), t[i](Z(e + n), l + e + n), t.setValueAtTime(m, d)), t[i](a, d + o);
};
function De(t, e, n, c, o, a) {
  const s = {
    threshold: e ?? -3,
    ratio: n ?? 10,
    knee: c ?? 10,
    attack: o ?? 5e-3,
    release: a ?? 0.05
  };
  return new DynamicsCompressorNode(t, s);
}
const v = (t, e = "linear", n) => {
  const [s, l, d, r] = t;
  if (s == null && l == null && d == null && r == null)
    return n ?? [1e-3, 1e-3, 1, 0.01];
  const i = d ?? (s != null && l == null || s == null && l == null ? 1 : 1e-3);
  return [Math.max(s ?? 0, 1e-3), Math.max(l ?? 0, 1e-3), Math.min(i, 1), Math.max(r ?? 0, 0.01)];
};
function zt(t, e, n, c, o, a, s, l, d, r, i, b, u, m) {
  const X = "exponential", [Z, p, y, h] = v([o, a, s, l], X, [5e-3, 0.14, 0, 0.1]);
  let V, f;
  if (u === "ladder" ? (V = I(t, "ladder-processor", { frequency: n, q: c, drive: m }), f = V.parameters.get("frequency")) : (V = t.createBiquadFilter(), V.type = e, V.Q.value = c, V.frequency.value = n, f = V.frequency), (o ?? a ?? s ?? l ?? d) !== void 0) {
    d = Q(d, 1, !0), b = Q(b, 0, !0);
    const M = Math.abs(d), N = M * b;
    let g = st(2 ** -N * n, 0, 2e4), S = st(2 ** (M - N) * n, 0, 2e4);
    return d < 0 && ([g, S] = [S, g]), B(f, Z, p, y, h, g, S, r, i, X), V;
  }
  return V;
}
let le = (t) => t < 0.5 ? 1 : 1 - (t - 0.5) / 0.5;
function Ee(t, e, n = 0) {
  const c = G();
  if (!n)
    return t;
  let o = c.createGain(), a = c.createGain();
  t.connect(o), e.connect(a), o.gain.value = le(n), a.gain.value = le(1 - n);
  let s = c.createGain();
  return o.connect(s), a.connect(s), s;
}
let Ae = ["linear", "exponential"];
function Xt(t, e, n, c) {
  if (!(e.pattack ?? e.pdecay ?? e.psustain ?? e.prelease ?? e.penv))
    return;
  const a = Q(e.penv, 1, !0), s = Ae[e.pcurve ?? 0];
  let [l, d, r, i] = v(
    [e.pattack, e.pdecay, e.psustain, e.prelease],
    s,
    [0.2, 1e-3, 1, 1e-3]
  ), b = e.panchor ?? r;
  const u = a * 100, m = 0 - u * b, X = u - u * b;
  B(t, l, d, r, i, m, X, n, c, s);
}
function Zt(t, e, n) {
  const { vibmod: c = 0.5, vib: o } = e;
  let a;
  if (o > 0) {
    a = G().createOscillator(), a.frequency.value = o;
    const s = G().createGain();
    return s.gain.value = c * 100, a.connect(s), s.connect(t), a.start(n), a;
  }
}
function Rt(t, e, n, c) {
  const o = t.createConstantSource();
  return o.start(n), o.stop(c), o.onended = () => {
    e();
  }, o;
}
const qe = (t, e = 1, n = "sine") => {
  const c = G(), o = c.createOscillator();
  o.type = n, o.frequency.value = t, o.start();
  const a = new GainNode(c, { gain: e });
  return o.connect(a), { node: a, stop: (s) => o.stop(s) };
}, _e = (t, e, n, c = "sine") => {
  const a = t.value * e, s = a * n;
  return qe(a, s, c);
};
function Ft(t, e, n) {
  const {
    fmh: c = 1,
    fmi: o,
    fmenv: a = "exp",
    fmattack: s,
    fmdecay: l,
    fmsustain: d,
    fmrelease: r,
    fmvelocity: i,
    fmwave: b = "sine",
    duration: u
  } = e;
  let m, X = () => {
  };
  if (o) {
    const p = G().createGain(), y = _e(t, c, o, b);
    if (m = y.node, X = y.stop, ![s, l, d, r, i].find((h) => h !== void 0))
      m.connect(t);
    else {
      const [h, V, f, x] = v([s, l, d, r]), M = n + u;
      B(
        p.gain,
        h,
        V,
        f,
        x,
        0,
        1,
        n,
        M,
        a === "exp" ? "exponential" : "linear"
      ), m.connect(p), p.connect(t);
    }
  }
  return { stop: X };
}
const Jt = {}, Lt = {}, wn = (t) => Jt[t];
function $e(t, e) {
  var n = 1024;
  if (t < n) return t + " B";
  var c = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], o = -1;
  do
    t /= n, ++o;
  while (t >= n);
  return t.toFixed(1) + " " + c[o];
}
function tn(t, e) {
  const { s: n, n: c = 0, speed: o = 1 } = t;
  let a = Ue(t, 36), s = a - 36, l, d = 0;
  if (Array.isArray(e))
    d = se(c, e.length), l = e[d];
  else {
    const b = (m) => yt(m) - a, u = Object.keys(e).filter((m) => !m.startsWith("_")).reduce(
      (m, X, Z) => !m || Math.abs(b(X)) < Math.abs(b(m)) ? X : m,
      null
    );
    s = -b(u), d = se(c, e[u].length), l = e[u][d];
  }
  const r = `${n}:${d}`;
  let i = Math.abs(o) * Math.pow(2, s / 12);
  return { transpose: s, sampleUrl: l, index: d, midi: a, label: r, playbackRate: i };
}
const en = async (t, e, n) => {
  let { sampleUrl: c, label: o, playbackRate: a } = tn(t, e);
  n && (c = await n(c));
  const s = G(), l = await be(c, s, o);
  return t.unit === "c" && (a = a * l.duration), { buffer: l, playbackRate: a };
}, nn = async (t, e, n) => {
  let { buffer: c, playbackRate: o } = await en(t, e, n);
  t.speed < 0 && (c = cn(c));
  const s = G().createBufferSource();
  s.buffer = c, s.playbackRate.value = o;
  const { s: l, loopBegin: d = 0, loopEnd: r = 1, begin: i = 0, end: b = 1 } = t, u = i * s.buffer.duration;
  (l.startsWith("wt_") ? 1 : t.loop) && (s.loop = !0, s.loopStart = d * s.buffer.duration - u, s.loopEnd = r * s.buffer.duration - u);
  const X = s.buffer.duration / s.playbackRate.value, Z = (b - i) * X;
  return { bufferSource: s, offset: u, bufferDuration: X, sliceDuration: Z };
}, be = (t, e, n, c = 0) => {
  const o = n ? `sound "${n}:${c}"` : "sample";
  if (t = t.replace("#", "%23"), !Lt[t]) {
    F(`[sampler] load ${o}..`, "load-sample", { url: t });
    const a = Date.now();
    Lt[t] = fetch(t).then((s) => s.arrayBuffer()).then(async (s) => {
      const l = Date.now() - a, d = $e(s.byteLength);
      F(`[sampler] load ${o}... done! loaded ${d} in ${l}ms`, "loaded-sample", { url: t });
      const r = await e.decodeAudioData(s);
      return Jt[t] = r, r;
    });
  }
  return Lt[t];
};
function cn(t) {
  const e = G(), n = e.createBuffer(t.numberOfChannels, t.length, e.sampleRate);
  for (let c = 0; c < t.numberOfChannels; c++)
    n.copyToChannel(t.getChannelData(c).slice().reverse(), c, c);
  return n;
}
const Yn = (t) => Jt[t];
function Xe(t) {
  if (t.startsWith("bubo:")) {
    const [e, n] = t.split(":");
    t = `github:Bubobubobubobubo/dough-${n}`;
  }
  return t;
}
function Ze(t, e = "") {
  if (!t.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let [n, c] = t.split("github:");
  return c = c.endsWith("/") ? c.slice(0, -1) : c, c.split("/").length === 2 && (c += "/main"), `https://raw.githubusercontent.com/${c}/${e}`;
}
const on = (t, e, n = t._base || "") => Object.entries(t).forEach(([c, o]) => {
  if (typeof o == "string" && (o = [o]), typeof o != "object")
    throw new Error("wrong sample map format for " + c);
  n = o._base || n, n = Xe(n), n.startsWith("github:") && (n = Ze(n, ""));
  const a = (s) => n + s;
  Array.isArray(o) ? o = o.map(a) : o = Object.fromEntries(
    Object.entries(o).map(([s, l]) => [s, (typeof l == "string" ? [l] : l).map(a)])
  ), e(c, o);
});
let he = {};
function Jn(t, e) {
  he[t] = e;
}
function sn(t) {
  const e = Object.entries(he).find(([n]) => t.startsWith(n));
  if (e)
    return e[1];
}
const an = async (t, e = t._base || "", n = {}) => {
  if (typeof t == "string") {
    const a = sn(t);
    if (a)
      return a(t);
    if (t = Xe(t), t.startsWith("github:") && (t = Ze(t, "strudel.json")), t.startsWith("local:") && (t = "http://localhost:5432"), t.startsWith("shabda:")) {
      let [l, d] = t.split("shabda:");
      t = `https://shabda.ndre.gr/${d}.json?strudel=1`;
    }
    if (t.startsWith("shabda/speech")) {
      let [l, d] = t.split("shabda/speech");
      d = d.startsWith("/") ? d.substring(1) : d;
      let [r, i] = d.split(":"), b = "f", u = "en-GB";
      r && ([u, b] = r.split("/")), t = `https://shabda.ndre.gr/speech/${i}.json?gender=${b}&language=${u}&strudel=1'`;
    }
    if (typeof fetch != "function")
      return;
    const s = t.split("/").slice(0, -1).join("/");
    return typeof fetch > "u" ? void 0 : fetch(t).then((l) => l.json()).then((l) => an(l, e || l._base || s, n)).catch((l) => {
      throw console.error(l), new Error(`error loading "${t}"`);
    });
  }
  const { prebake: c, tag: o } = n;
  on(
    t,
    (a, s) => E(a, (l, d, r) => ln(l, d, r, s), {
      type: "sample",
      samples: s,
      baseUrl: e,
      prebake: c,
      tag: o
    }),
    e
  );
}, de = [];
async function ln(t, e, n, c, o) {
  let {
    s: a,
    nudge: s = 0,
    // TODO: is this in seconds?
    cut: l,
    loop: d,
    clip: r = void 0,
    // if set, samples will be cut off when the hap ends
    n: i = 0,
    speed: b = 1,
    // sample playback speed
    duration: u
  } = e;
  if (b === 0)
    return;
  const m = G();
  let [X, Z, p, y] = v([e.attack, e.decay, e.sustain, e.release]);
  const { bufferSource: h, sliceDuration: V, offset: f } = await nn(e, c, o);
  if (m.currentTime > t) {
    F(`[sampler] still loading sound "${a}:${i}"`, "highlight");
    return;
  }
  if (!h) {
    F(`[sampler] could not load "${a}:${i}"`, "error");
    return;
  }
  let x = Zt(h.detune, e, t);
  const M = t + s;
  h.start(M, f);
  const N = m.createGain(), g = h.connect(N);
  r == null && d == null && e.release == null && (u = V);
  let S = t + u;
  B(g.gain, X, Z, p, y, 0, 1, t, S, "linear"), Xt(h.detune, e, t, S);
  const K = m.createGain();
  g.connect(K), h.onended = function() {
    h.disconnect(), x?.stop(), g.disconnect(), K.disconnect(), n();
  };
  let j = S + y + 0.01;
  h.stop(j);
  const H = { node: K, bufferSource: h, stop: (P) => {
    h.stop(P);
  } };
  if (l !== void 0) {
    const P = de[l];
    P && (P.node.gain.setValueAtTime(1, M), P.node.gain.linearRampToValueAtTime(0, M + 0.01)), de[l] = H;
  }
  return H;
}
const pe = 128, Tt = "System Standard";
let ye = pe;
function dn(t) {
  ye = parseInt(t) ?? pe;
}
let Ge = !1;
function rn(t) {
  Ge = t == !0;
}
const at = Ce();
function E(t, e, n = {}) {
  t = t.toLowerCase().replace(/\s+/g, "_"), at.setKey(t, { onTrigger: e, data: n });
}
let Ve = (t) => t;
function q(t) {
  return Ve(t);
}
function Cn(t) {
  Ve = t;
}
function wt(t) {
  for (const n in t)
    t[n.toLowerCase()] = t[n];
  const e = at.get();
  for (const n in e) {
    const [c, o] = n.split("_");
    if (!o) continue;
    const a = t[c];
    if (a) {
      if (typeof a == "string")
        e[`${a}_${o}`.toLowerCase()] = e[n];
      else if (Array.isArray(a))
        for (const s of a)
          e[`${s}_${o}`.toLowerCase()] = e[n];
    }
  }
  at.set({ ...e });
}
async function un(t) {
  const n = await (await fetch(t)).json();
  wt(n);
}
async function In(...t) {
  switch (t.length) {
    case 1:
      return typeof t[0] == "string" ? un(t[0]) : wt(t[0]);
    case 2:
      return wt({ [t[0]]: t[1] });
    default:
      throw new Error("aliasMap expects 1 or 2 arguments, received " + t.length);
  }
}
function gt(t) {
  return at.get()[t.toLowerCase()];
}
const mn = async () => {
  await navigator.mediaDevices.getUserMedia({ audio: !0 });
  let t = await navigator.mediaDevices.enumerateDevices();
  t = t.filter((n) => n.kind === "audiooutput" && n.deviceId !== "default");
  const e = /* @__PURE__ */ new Map();
  return e.set(Tt, ""), t.forEach((n) => {
    e.set(n.label, n.deviceId);
  }), e;
}, We = {
  s: "triangle",
  gain: 0.8,
  postgain: 1,
  density: ".03",
  ftype: "12db",
  fanchor: 0,
  resonance: 1,
  hresonance: 1,
  bandq: 1,
  channels: [1, 2],
  phaserdepth: 0.75,
  shapevol: 1,
  distortvol: 1,
  delay: 0,
  byteBeatExpression: "0",
  delayfeedback: 0.5,
  delaytime: 0.25,
  orbit: 1,
  i: 1,
  velocity: 1,
  fft: 8
};
let Ct = new Map(Object.entries(We));
function fe(t, e) {
  Ct.set(t, e);
}
function L(t) {
  return Ct.get(t);
}
function Pn(t) {
  Object.keys(t).forEach((e) => {
    fe(e, t[e]);
  });
}
function bn() {
  Ct = new Map(Object.entries(We));
}
function kn(t) {
  bn(), t === "1.0" && fe("fanchor", 0.5);
}
const Bn = () => at.set({});
let ht;
const Xn = () => (ht = new AudioContext(), ht), G = () => ht || Xn();
function vn() {
  return G().currentTime;
}
let Kt;
function Zn() {
  return Kt || (Kt = G().audioWorklet.addModule(Oe)), Kt;
}
async function hn(t = {}) {
  const {
    disableWorklets: e = !1,
    maxPolyphony: n,
    audioDeviceName: c = Tt,
    multiChannelOrbits: o = !1
  } = t;
  if (dn(n), rn(o), typeof window > "u")
    return;
  const a = G();
  if (c != null && c != Tt)
    try {
      const l = (await mn()).get(c), d = (l ?? "").length > 0;
      a.sinkId !== l && d && await a.setSinkId(l), F(
        `[superdough] Audio Device set to ${c}, it might take a few seconds before audio plays on all output channels`
      );
    } catch {
      F("[superdough] failed to set audio interface", "warning");
    }
  if (await a.resume(), e) {
    F("[superdough]: AudioWorklets disabled with disableWorklets");
    return;
  }
  try {
    await Zn(), F("[superdough] AudioWorklets loaded");
  } catch (s) {
    console.warn("could not load AudioWorklet effects", s);
  }
  F("[superdough] ready");
}
let St;
async function Qn(t) {
  return St || (St = new Promise((e) => {
    document.addEventListener("click", async function n() {
      document.removeEventListener("click", n), await hn(t), e();
    });
  })), St;
}
let O = {}, pt, _;
function pn() {
  const t = G(), e = t.destination.maxChannelCount;
  t.destination.channelCount = e, pt = new ChannelMergerNode(t, { numberOfInputs: t.destination.channelCount }), _ = new GainNode(t), pt.connect(_), _.connect(t.destination);
}
const It = (t, e = [0, 1]) => {
  const n = G();
  pt == null && pn();
  const c = new StereoPannerNode(n);
  t.connect(c);
  const o = new ChannelSplitterNode(n, {
    numberOfOutputs: c.channelCount
  });
  c.connect(o), e.forEach((a, s) => {
    o.connect(pt, s % c.channelCount, a % n.destination.channelCount);
  });
}, jn = () => {
  _ != null && (_.gain.linearRampToValueAtTime(0, G().currentTime + 0.01), _ = null);
};
function yn(t, e, n, c, o) {
  if (n = st(n, 0, 0.98), !O[t]) {
    const s = G().createFeedbackDelay(1, e, n);
    s.start?.(c), It(s, o), O[t] = s;
  }
  return O[t].delayTime.value !== e && O[t].delayTime.setValueAtTime(e, c), O[t].feedback.value !== n && O[t].feedback.setValueAtTime(n, c), O[t];
}
function xe(t, e, n, c = {}) {
  return I(t, "lfo-processor", {
    frequency: 1,
    depth: 1,
    skew: 0,
    phaseoffset: 0,
    time: e,
    end: n,
    shape: 1,
    dcoffset: -0.5,
    ...c
  });
}
function Gn(t, e, n = 1, c = 0.5, o = 1e3, a = 2e3) {
  const s = G(), l = xe(s, t, e, { frequency: n, depth: a * 2 }), d = 2;
  let r = 0;
  const i = [];
  for (let b = 0; b < d; b++) {
    const u = s.createBiquadFilter();
    u.type = "notch", u.gain.value = 1, u.frequency.value = o + r, u.Q.value = 2 - Math.min(Math.max(c * 2, 0), 1.9), l.connect(u.detune), r += 282, b > 0 && i[b - 1].connect(u), i.push(u);
  }
  return i[i.length - 1];
}
function Vn(t) {
  t = t ?? 0;
  const e = ["12db", "ladder", "24db"];
  return typeof t == "number" ? e[Math.floor(me(t, e.length))] : t;
}
let J = {}, ut = (t, e) => t !== void 0 && t !== e;
function Wn(t, e, n, c, o, a, s) {
  if (!J[t]) {
    const d = G().createReverb(e, n, c, o, a);
    It(d, s), J[t] = d;
  }
  return (ut(e, J[t].duration) || ut(n, J[t].fade) || ut(c, J[t].lp) || ut(o, J[t].dim) || J[t].ir !== a) && J[t].generate(e, n, c, o, a), J[t];
}
let C = {}, $ = {};
function fn(t, e = 1024, n = 0.5) {
  if (!C[t]) {
    const c = G().createAnalyser();
    c.fftSize = e, c.smoothingTimeConstant = n, C[t] = c, $[t] = new Float32Array(C[t].frequencyBinCount);
  }
  return C[t].fftSize !== e && (C[t].fftSize = e, $[t] = new Float32Array(C[t].frequencyBinCount)), C[t];
}
function Un(t = "time", e = 1) {
  const n = {
    time: () => C[e]?.getFloatTimeDomainData($[e]),
    frequency: () => C[e]?.getFloatFrequencyData($[e])
  }[t];
  if (!n)
    throw new Error(`getAnalyzerData: ${t} not supported. use one of ${Object.keys(n).join(", ")}`);
  return n(), $[e];
}
function Ht(t, e, n) {
  const c = k(n);
  return t.connect(c), c.connect(e), c;
}
function On() {
  O = {}, J = {}, C = {}, $ = {};
}
let ot = /* @__PURE__ */ new Map();
function re(t) {
  return (Array.isArray(t) ? t : [t]).map((e) => e - 1);
}
const xn = async (t, e, n, c) => {
  const o = G();
  e = typeof e == "string" && e.startsWith("=") ? Number(e.slice(1)) : o.currentTime + e;
  let { stretch: a } = t;
  if (a != null && (e = e - 0.04), typeof t != "object")
    throw new Error(
      `expected hap.value to be an object, but got "${t}". Hint: append .note() or .s() to the end`,
      "error"
    );
  if (t.duration = n, e < o.currentTime) {
    console.warn(
      `[superdough]: cannot schedule sounds in the past (target: ${e.toFixed(2)}, now: ${o.currentTime.toFixed(2)})`
    );
    return;
  }
  let {
    s = L("s"),
    bank: l,
    source: d,
    gain: r = L("gain"),
    postgain: i = L("postgain"),
    density: b = L("density"),
    // filters
    fanchor: u = L("fanchor"),
    drive: m = 0.69,
    // low pass
    cutoff: X,
    lpenv: Z,
    lpattack: p,
    lpdecay: y,
    lpsustain: h,
    lprelease: V,
    resonance: f = L("resonance"),
    // high pass
    hpenv: x,
    hcutoff: M,
    hpattack: N,
    hpdecay: g,
    hpsustain: S,
    hprelease: K,
    hresonance: j = L("hresonance"),
    // band pass
    bpenv: z,
    bandf: H,
    bpattack: P,
    bpdecay: Gt,
    bpsustain: T,
    bprelease: et,
    bandq: U = L("bandq"),
    //phaser
    phaserrate: lt,
    phaserdepth: Pt = L("phaserdepth"),
    phasersweep: Re,
    phasercenter: Le,
    //
    coarse: kt,
    crush: Bt,
    shape: vt,
    shapevol: Vt = L("shapevol"),
    distort: Qt,
    distortvol: Wt = L("distortvol"),
    pan: jt,
    vowel: Ut,
    delay: dt = L("delay"),
    delayfeedback: Ot = L("delayfeedback"),
    delaytime: Dt = L("delaytime"),
    orbit: nt = L("orbit"),
    room: Et,
    roomfade: ge,
    roomlp: Ke,
    roomdim: Se,
    roomsize: He,
    ir: ft,
    i: At = L("i"),
    velocity: xt = L("velocity"),
    analyze: qt,
    // analyser wet
    fft: Ne = L("fft"),
    // fftSize 0 - 10
    compressor: _t,
    compressorRatio: Fe,
    compressorKnee: Te,
    compressorAttack: we,
    compressorRelease: Ye
  } = t;
  const Mt = re(
    Ge && nt > 0 ? [nt * 2 - 1, nt * 2] : L("channels")
  ), Je = t.channels != null ? re(t.channels) : Mt;
  r = q(Q(r, 1)), i = q(i), Vt = q(Vt), Wt = q(Wt), dt = q(dt), xt = q(xt), r *= xt;
  const $t = Math.round(Math.random() * 1e6);
  for (let W = 0; W <= ot.size - ye; W++) {
    const D = ot.entries().next(), w = D.value[1], Y = D.value[0], ce = e + 0.25;
    w?.node?.gain?.linearRampToValueAtTime(0, ce), w?.stop?.(ce), ot.delete(Y);
  }
  let A = [];
  l && s && (s = `${l}_${s}`, t.s = s);
  let rt;
  if (d)
    rt = d(e, t, n, c);
  else if (gt(s)) {
    const { onTrigger: W } = gt(s), w = await W(e, t, () => {
      A.forEach((Y) => Y?.disconnect()), ot.delete($t);
    });
    w && (rt = w.node, ot.set($t, w));
  } else
    throw new Error(`sound ${s} not found! Is it loaded?`);
  if (!rt)
    return;
  if (o.currentTime > e) {
    F("[webaudio] skip hap: still loading", o.currentTime - e);
    return;
  }
  const R = [];
  R.push(rt), a !== void 0 && R.push(I(o, "phase-vocoder-processor", { pitchFactor: a })), R.push(k(r));
  const it = Vn(t.ftype);
  if (X !== void 0) {
    let W = () => zt(
      o,
      "lowpass",
      X,
      f,
      p,
      y,
      h,
      V,
      Z,
      e,
      e + n,
      u,
      it,
      m
    );
    R.push(W()), it === "24db" && R.push(W());
  }
  if (M !== void 0) {
    let W = () => zt(
      o,
      "highpass",
      M,
      j,
      N,
      g,
      S,
      K,
      x,
      e,
      e + n,
      u
    );
    R.push(W()), it === "24db" && R.push(W());
  }
  if (H !== void 0) {
    let W = () => zt(
      o,
      "bandpass",
      H,
      U,
      P,
      Gt,
      T,
      et,
      z,
      e,
      e + n,
      u
    );
    R.push(W()), it === "24db" && R.push(W());
  }
  if (Ut !== void 0) {
    const W = o.createVowelFilter(Ut);
    R.push(W);
  }
  if (kt !== void 0 && R.push(I(o, "coarse-processor", { coarse: kt })), Bt !== void 0 && R.push(I(o, "crush-processor", { crush: Bt })), vt !== void 0 && R.push(I(o, "shape-processor", { shape: vt, postgain: Vt })), Qt !== void 0 && R.push(I(o, "distort-processor", { distort: Qt, postgain: Wt })), _t !== void 0 && R.push(
    De(o, _t, Fe, Te, we, Ye)
  ), jt !== void 0) {
    const W = o.createStereoPanner();
    W.pan.value = 2 * jt - 1, R.push(W);
  }
  if (lt !== void 0 && Pt > 0) {
    const W = Gn(e, e + n, lt, Pt, Le, Re);
    R.push(W);
  }
  const ct = new GainNode(o, { gain: i });
  R.push(ct), It(ct, Je);
  let te;
  if (dt > 0 && Dt > 0 && Ot > 0) {
    const W = yn(nt, Dt, Ot, e, Mt);
    te = Ht(ct, W, dt), A.push(te);
  }
  let ee;
  if (Et > 0) {
    let W;
    if (ft !== void 0) {
      let w, Y = gt(ft);
      Array.isArray(Y) ? w = Y.data.samples[At % Y.data.samples.length] : typeof Y == "object" && (w = Object.values(Y.data.samples).flat()[At % Object.values(Y.data.samples).length]), W = await be(w, o, ft, 0);
    }
    const D = Wn(nt, He, ge, Ke, Se, W, Mt);
    ee = Ht(ct, D, Et), A.push(ee);
  }
  let ne;
  if (qt) {
    const W = fn(qt, 2 ** (Ne + 5));
    ne = Ht(ct, W, 1), A.push(ne);
  }
  R.slice(1).reduce((W, D) => W.connect(D), R[0]), A = A.concat(R);
}, Dn = (t, e, n, c) => {
  xn(e, t - n, e.duration / c, c);
};
let Nt = {};
function Mn(t, e) {
  const n = G();
  if (Nt[t])
    return Nt[t];
  const c = 2 * n.sampleRate, o = n.createBuffer(1, c, n.sampleRate), a = o.getChannelData(0);
  let s = 0, l, d, r, i, b, u, m;
  l = d = r = i = b = u = m = 0;
  for (let X = 0; X < c; X++)
    if (t === "white")
      a[X] = Math.random() * 2 - 1;
    else if (t === "brown") {
      let Z = Math.random() * 2 - 1;
      a[X] = (s + 0.02 * Z) / 1.02, s = a[X];
    } else if (t === "pink") {
      let Z = Math.random() * 2 - 1;
      l = 0.99886 * l + Z * 0.0555179, d = 0.99332 * d + Z * 0.0750759, r = 0.969 * r + Z * 0.153852, i = 0.8665 * i + Z * 0.3104856, b = 0.55 * b + Z * 0.5329522, u = -0.7616 * u - Z * 0.016898, a[X] = l + d + r + i + b + u + m + Z * 0.5362, a[X] *= 0.11, m = Z * 0.115926;
    } else if (t === "crackle") {
      const Z = e * 0.01;
      Math.random() < Z ? a[X] = Math.random() * 2 - 1 : a[X] = 0;
    }
  return t !== "crackle" && (Nt[t] = o), o;
}
function Me(t = "white", e, n = 0.02) {
  const o = G().createBufferSource();
  return o.buffer = Mn(t, n), o.loop = !0, o.start(e), {
    node: o,
    stop: (a) => o.stop(a)
  };
}
function zn(t, e, n) {
  const c = Me("pink", n);
  return {
    node: Ee(t, c.node, e),
    stop: (a) => c?.stop(a)
  };
}
const bt = (t) => {
  let { note: e, freq: n } = t;
  return e = e || 36, typeof e == "string" && (e = yt(e)), !n && typeof e == "number" && (n = ue(e)), Number(n);
};
function mt(t) {
  t != null && (t.disconnect(), t.parameters.get("end")?.setValueAtTime(0, 0));
}
const Rn = ["triangle", "square", "sawtooth", "sine"], Ln = ["pink", "white", "brown", "crackle"];
function En() {
  [...Rn].forEach((t) => {
    E(
      t,
      (e, n, c) => {
        const [o, a, s, l] = v(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let d = Kn(t, e, n), { node: r, stop: i, triggerRelease: b } = d;
        const u = k(0.3), { duration: m } = n;
        r.onended = () => {
          r.disconnect(), u.disconnect(), c();
        };
        const X = k(1);
        let Z = r.connect(u).connect(X);
        const p = e + m;
        B(Z.gain, o, a, s, l, 0, 1, e, p, "linear");
        const y = p + l + 0.01;
        return b?.(y), i(y), {
          node: Z,
          stop: (h) => {
            i(h);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  }), E(
    "supersaw",
    (t, e, n) => {
      const c = G();
      let { duration: o, n: a, unison: s = 5, spread: l = 0.6, detune: d } = e;
      d = d ?? a ?? 0.18;
      const r = bt(e), [i, b, u, m] = v(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), X = t + o, Z = X + m + 0.01, p = st(s, 1, 100);
      let y = p > 1 ? st(l, 0, 1) : 0, h = I(
        c,
        "supersaw-oscillator",
        {
          frequency: r,
          begin: t,
          end: Z,
          freqspread: d,
          voices: p,
          panspread: y
        },
        {
          outputChannelCount: [2]
        }
      );
      const V = 1 / Math.sqrt(p);
      Xt(h.parameters.get("detune"), e, t, X);
      const f = Zt(h.parameters.get("detune"), e, t), x = Ft(h.parameters.get("frequency"), e, t);
      let M = k(1);
      M = h.connect(M), B(M.gain, i, b, u, m, 0, 0.3 * V, t, X, "linear");
      let N = Rt(
        c,
        () => {
          mt(h), M.disconnect(), n(), x?.stop(), f?.stop();
        },
        t,
        Z
      );
      return {
        node: M,
        stop: (g) => {
          N.stop(g);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), E(
    "bytebeat",
    (t, e, n) => {
      const c = [
        "(t%255 >= t/255%255)*255",
        "(t*(t*8%60 <= 300)|(-t)*(t*4%512 < 256))+t/400",
        "t",
        "t*(t >> 10^t)",
        "t&128",
        "t&t>>8",
        "((t%255+t%128+t%64+t%32+t%16+t%127.8+t%64.8+t%32.8+t%16.8)/3)",
        "((t%64+t%63.8+t%64.15+t%64.35+t%63.5)/1.25)",
        "(t&(t>>7)-t)",
        "(sin(t*PI/128)*127+127)",
        "((t^t/2+t+64*(sin((t*PI/64)+(t*PI/32768))+64))%128*2)",
        "((t^t/2+t+64*(cos >> 0))%127.85*2)",
        "((t^t/2+t+64)%128*2)",
        "(((t * .25)^(t * .25)/100+(t * .25))%128)*2",
        "((t^t/2+t+64)%7 * 24)"
      ], { n: o = 0 } = e, a = bt(e), { byteBeatExpression: s = c[o % c.length], byteBeatStartTime: l } = e, d = G();
      let { duration: r } = e;
      const [i, b, u, m] = v(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), X = t + r, Z = X + m + 0.01;
      let p = I(
        d,
        "byte-beat-processor",
        {
          frequency: a,
          begin: t,
          end: Z
        },
        {
          outputChannelCount: [2]
        }
      );
      p.port.postMessage({ codeText: s, byteBeatStartTime: l, frequency: a });
      let y = k(1);
      y = p.connect(y), B(y.gain, i, b, u, m, 0, 1, t, X, "linear");
      let h = Rt(
        d,
        () => {
          mt(p), y.disconnect(), n();
        },
        t,
        Z
      );
      return {
        node: y,
        stop: (V) => {
          h.stop(V);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), E(
    "pulse",
    (t, e, n) => {
      const c = G();
      let { pwrate: o, pwsweep: a } = e;
      a == null && (o != null ? a = 0.3 : a = 0), o == null && a != null && (o = 1);
      let { duration: s, pw: l = 0.5 } = e;
      const d = bt(e), [r, i, b, u] = v(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), m = t + s, X = m + u + 0.01;
      let Z = I(
        c,
        "pulse-oscillator",
        {
          frequency: d,
          begin: t,
          end: X,
          pulsewidth: l
        },
        {
          outputChannelCount: [2]
        }
      );
      Xt(Z.parameters.get("detune"), e, t, m);
      const p = Zt(Z.parameters.get("detune"), e, t), y = Ft(Z.parameters.get("frequency"), e, t);
      let h = k(1);
      h = Z.connect(h), B(h.gain, r, i, b, u, 0, 1, t, m, "linear");
      let V;
      a != 0 && (V = xe(c, t, X, { frequency: o, depth: a }), V.connect(Z.parameters.get("pulsewidth")));
      let f = Rt(
        c,
        () => {
          mt(Z), mt(V), h.disconnect(), n(), y?.stop(), p?.stop();
        },
        t,
        X
      );
      return {
        node: h,
        stop: (x) => {
          f.stop(x);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), [...Ln].forEach((t) => {
    E(
      t,
      (e, n, c) => {
        const [o, a, s, l] = v(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let d, { density: r } = n;
        d = Me(t, e, r);
        let { node: i, stop: b, triggerRelease: u } = d;
        const m = k(0.3), { duration: X } = n;
        i.onended = () => {
          i.disconnect(), m.disconnect(), c();
        };
        const Z = k(1);
        let p = i.connect(m).connect(Z);
        const y = e + X;
        B(p.gain, o, a, s, l, 0, 1, e, y, "linear");
        const h = y + l + 0.01;
        return u?.(h), b(h), {
          node: p,
          stop: (V) => {
            b(V);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
function gn(t, e) {
  const n = new Float32Array(t + 1), c = new Float32Array(t + 1), o = G(), a = o.createOscillator(), s = {
    sawtooth: (r) => [0, -1 / r],
    square: (r) => [0, r % 2 === 0 ? 0 : 1 / r],
    triangle: (r) => [r % 2 === 0 ? 0 : 1 / (r * r), 0]
  };
  if (!s[e])
    throw new Error(`unknown wave type ${e}`);
  n[0] = 0, c[0] = 0;
  let l = 1;
  for (; l <= t; ) {
    const [r, i] = s[e](l);
    n[l] = r, c[l] = i, l++;
  }
  const d = o.createPeriodicWave(n, c);
  return a.setPeriodicWave(d), a;
}
function Kn(t, e, n) {
  let { n: c, duration: o, noise: a = 0 } = n, s;
  !c || t === "sine" ? (s = G().createOscillator(), s.type = t || "triangle") : s = gn(c, t), s.frequency.value = bt(n), s.start(e);
  let l = Zt(s.detune, n, e);
  Xt(s.detune, n, e, e + o);
  const d = Ft(s.frequency, n, e);
  let r;
  return a && (r = zn(s, a, e)), {
    node: r?.node || s,
    stop: (i) => {
      d.stop(i), l?.stop(i), r?.stop(i), s.stop(i);
    },
    triggerRelease: (i) => {
    }
  };
}
function Sn(t = 1, e = 0.05, n = 220, c = 0, o = 0, a = 0.1, s = 0, l = 1, d = 0, r = 0, i = 0, b = 0, u = 0, m = 0, X = 0, Z = 0, p = 0, y = 1, h = 0, V = 0) {
  let f = Math.PI * 2, x = G().sampleRate, M = (lt) => lt > 0 ? 1 : -1, N = d *= 500 * f / x / x, g = n *= (1 + e * 2 * Math.random() - e) * f / x, S = [], K = 0, j = 0, z = 0, H = 1, P = 0, Gt = 0, T = 0, et, U;
  for (c = c * x + 9, h *= x, o *= x, a *= x, p *= x, r *= 500 * f / x ** 3, X *= f / x, i *= f / x, b *= x, u = u * x | 0, U = c + h + o + a + p | 0; z < U; S[z++] = T)
    ++Gt % (Z * 100 | 0) || (T = s ? s > 1 ? s > 2 ? s > 3 ? Math.sin((K % f) ** 3) : Math.max(Math.min(Math.tan(K), 1), -1) : 1 - (2 * K / f % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(K / f) - K / f) : Math.sin(K), T = (u ? 1 - V + V * Math.sin(f * z / u) : 1) * M(T) * Math.abs(T) ** l * // curve 0=square, 2=pointy
    t * 1 * // envelope
    (z < c ? z / c : z < c + h ? 1 - (z - c) / h * (1 - y) : z < c + h + o ? y : z < U - p ? (U - z - p) / a * // release falloff
    y : 0), T = p ? T / 2 + (p > z ? 0 : (z < U - p ? 1 : (U - z) / p) * // release delay
    S[z - p | 0] / 2) : T), et = (n += d += r) * // frequency
    Math.cos(X * j++), K += et - et * m * (1 - (Math.sin(z) + 1) * 1e9 % 2), H && ++H > b && (n += i, g += i, H = 0), u && !(++P % u) && (n = g, d = N, H ||= 1);
  return S;
}
const Hn = (t, e) => {
  let {
    s: n,
    note: c = 36,
    freq: o,
    //
    zrand: a = 0,
    attack: s = 0,
    decay: l = 0,
    sustain: d = 0.8,
    release: r = 0.1,
    curve: i = 1,
    slide: b = 0,
    deltaSlide: u = 0,
    pitchJump: m = 0,
    pitchJumpTime: X = 0,
    lfo: Z = 0,
    znoise: p = 0,
    zmod: y = 0,
    zcrush: h = 0,
    zdelay: V = 0,
    tremolo: f = 0,
    duration: x = 0.2,
    zzfx: M
  } = t;
  const N = Math.max(x - s - l, 0);
  typeof c == "string" && (c = yt(c)), !o && typeof c == "number" && (o = ue(c)), n = n.replace("z_", "");
  const g = ["sine", "triangle", "sawtooth", "tan", "noise"].indexOf(n) || 0;
  i = n === "square" ? 0 : i;
  const K = (
    /* ZZFX. */
    Sn(...M || [
      0.25,
      // volume
      a,
      o,
      s,
      N,
      r,
      g,
      i,
      b,
      u,
      m,
      X,
      Z,
      p,
      y,
      h,
      V,
      d,
      // sustain volume!
      l,
      f
    ])
  ), j = G(), z = j.createBuffer(1, K.length, j.sampleRate);
  z.getChannelData(0).set(K);
  const H = G().createBufferSource();
  return H.buffer = z, H.start(e), {
    node: H
  };
};
function An() {
  ["zzfx", "z_sine", "z_sawtooth", "z_triangle", "z_square", "z_tan", "z_noise"].forEach((t) => {
    E(
      t,
      (e, n, c) => {
        const { node: o } = Hn({ s: t, ...n }, e);
        return o.onended = () => {
          o.disconnect(), c();
        }, {
          node: o,
          stop: () => {
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
let tt;
async function Nn(t, e) {
  const n = `dsp-worklet-${Date.now()}`, c = `${e}
let __q = []; // trigger queue
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.t = 0;
    this.stopped = false;
    this.port.onmessage = (e) => {
      if(e.data==='stop') {
        this.stopped = true;
      } else if(e.data?.dough) {
        __q.push(e.data)
      } else {
        msg?.(e.data)
      }
    };
  }
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    if(__q.length) {
      for(let i=0;i<__q.length;++i) {
        const deadline = __q[i].time-currentTime;
        if(deadline<=0) {
          trigger(__q[i].dough)
          __q.splice(i,1)
        }
      }
    }
    for (let i = 0; i < output[0].length; i++) {
      const out = dsp(this.t / sampleRate);
      output.forEach((channel) => {
        channel[i] = out;
      });
      this.t++;
    }
  return !this.stopped;
  }
}
registerProcessor('${n}', MyProcessor);
`, a = `data:text/javascript;base64,${btoa(c)}`;
  await t.audioWorklet.addModule(a);
  const s = new AudioWorkletNode(t, n);
  return { node: s, stop: () => s.port.postMessage("stop") };
}
const ze = () => {
  tt && (tt?.stop(), tt?.node?.disconnect());
};
typeof window < "u" && window.addEventListener("message", (t) => {
  t.data === "strudel-stop" ? ze() : t.data?.dough && tt?.node.port.postMessage(t.data);
});
const qn = async (t) => {
  const e = G();
  ze(), tt = await Nn(e, t), tt.node.connect(e.destination);
};
function _n(t, e, n, c, o) {
  window.postMessage({ time: o, dough: e.value, currentTime: n, duration: e.duration, cps: c });
}
export {
  pe as DEFAULT_MAX_POLYPHONY,
  In as aliasBank,
  C as analysers,
  $ as analysersData,
  Ft as applyFM,
  q as applyGainCurve,
  It as connectToDestination,
  zt as createFilter,
  qn as dough,
  _n as doughTrigger,
  Ee as drywet,
  Nn as dspWorklet,
  k as gainNode,
  v as getADSRValues,
  fn as getAnalyserById,
  Un as getAnalyzerData,
  G as getAudioContext,
  vn as getAudioContextCurrentTime,
  mn as getAudioDevices,
  wn as getCachedBuffer,
  De as getCompressor,
  L as getDefaultValue,
  xe as getLfo,
  Yn as getLoadedBuffer,
  Kn as getOscillator,
  B as getParamADSR,
  Xt as getPitchEnvelope,
  en as getSampleBuffer,
  nn as getSampleBufferSource,
  tn as getSampleInfo,
  gt as getSound,
  Zt as getVibratoOscillator,
  I as getWorklet,
  Hn as getZZFX,
  hn as initAudio,
  Qn as initAudioOnFirstClick,
  pn as initializeAudioOutput,
  be as loadBuffer,
  F as logger,
  ln as onTriggerSample,
  jn as panic,
  on as processSampleMap,
  Jn as registerSamplesPrefix,
  E as registerSound,
  En as registerSynthSounds,
  An as registerZZFXSounds,
  bn as resetDefaultValues,
  On as resetGlobalEffects,
  Bn as resetLoadedSounds,
  cn as reverseBuffer,
  an as samples,
  Xn as setDefaultAudioContext,
  fe as setDefaultValue,
  Pn as setDefaultValues,
  Cn as setGainCurve,
  Tn as setLogger,
  dn as setMaxPolyphony,
  rn as setMultiChannelOrbits,
  kn as setVersionDefaults,
  at as soundMap,
  xn as superdough,
  Dn as superdoughTrigger,
  gn as waveformN,
  Rt as webAudioTimeout
};
