import { detect } from '@tonaljs/chord-detect';
export { detect } from '@tonaljs/chord-detect';
import { ChordType } from '@tonaljs/chord-type';
import { NoteName } from '@tonaljs/pitch-note';

type ChordNameOrTokens = string | [string] | [string, string] | [string, string, string];
type ChordNameTokens = [string, string, string];
interface Chord extends ChordType {
    tonic: string | null;
    type: string;
    root: string;
    bass: string;
    rootDegree: number;
    symbol: string;
    notes: NoteName[];
}
/**
 * Tokenize a chord name. It returns an array with the tonic, chord type and bass
 * If not tonic is found, all the name is considered the chord name.
 *
 * This function does NOT check if the chord type exists or not. It only tries
 * to split the tonic and chord type.
 *
 * This function does NOT check if the bass is part of the chord or not but it
 * only accepts a pitch class as bass
 *
 * @function
 * @param {string} name - the chord name
 * @return {Array} an array with [tonic, type, bass]
 * @example
 * tokenize("Cmaj7") // => [ "C", "maj7" ]
 * tokenize("C7") // => [ "C", "7" ]
 * tokenize("mMaj7") // => [ null, "mMaj7" ]
 * tokenize("Cnonsense") // => [ null, "nonsense" ]
 */
declare function tokenize(name: string): ChordNameTokens;
/**
 * Get a Chord from a chord name.
 */
declare function get(src: ChordNameOrTokens): Chord;
/**
 * Get chord properties
 *
 * @param typeName - the chord type name
 * @param [tonic] - Optional tonic
 * @param [root]  - Optional root (requires a tonic)
 */
declare function getChord(typeName: string, optionalTonic?: string, optionalBass?: string): Chord;
declare const chord: typeof get;
/**
 * Transpose a chord name
 *
 * @param {string} chordName - the chord name
 * @return {string} the transposed chord
 *
 * @example
 * transpose('Dm7', 'P4') // => 'Gm7
 */
declare function transpose(chordName: string, interval: string): string;
/**
 * Get all scales where the given chord fits
 *
 * @example
 * chordScales('C7b9')
 * // => ["phrygian dominant", "flamenco", "spanish heptatonic", "half-whole diminished", "chromatic"]
 */
declare function chordScales(name: string): string[];
/**
 * Get all chords names that are a superset of the given one
 * (has the same notes and at least one more)
 *
 * @function
 * @example
 * extended("CMaj7")
 * // => [ 'Cmaj#4', 'Cmaj7#9#11', 'Cmaj9', 'CM7add13', 'Cmaj13', 'Cmaj9#11', 'CM13#11', 'CM7b9' ]
 */
declare function extended(chordName: string): string[];
/**
 * Find all chords names that are a subset of the given one
 * (has less notes but all from the given chord)
 *
 * @example
 */
declare function reduced(chordName: string): string[];
/**
 * Return the chord notes
 */
declare function notes(chordName: ChordNameOrTokens, tonic?: string): string[];
/**
 * Returns a function to get a note name from the scale degree.
 *
 * @example
 * [1, 2, 3, 4].map(Chord.degrees("C")) => ["C", "E", "G", "C"]
 * [1, 2, 3, 4].map(Chord.degrees("C4")) => ["C4", "E4", "G4", "C5"]
 */
declare function degrees(chordName: ChordNameOrTokens, tonic?: string): (degree: number) => string;
/**
 * Sames as `degree` but with 0-based index
 */
declare function steps(chordName: ChordNameOrTokens, tonic?: string): (normalized: number) => string;
/** @deprecated */
declare const _default: {
    getChord: typeof getChord;
    get: typeof get;
    detect: typeof detect;
    chordScales: typeof chordScales;
    extended: typeof extended;
    reduced: typeof reduced;
    tokenize: typeof tokenize;
    transpose: typeof transpose;
    degrees: typeof degrees;
    steps: typeof steps;
    notes: typeof notes;
    chord: typeof get;
};

export { type Chord, chord, chordScales, _default as default, degrees, extended, get, getChord, notes, reduced, steps, tokenize, transpose };
